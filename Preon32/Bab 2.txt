Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat “\textit{self synchronizing}” yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}

%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk “USB 3.1 yang sesungguhnya”, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat “\textit{self synchronizing}” yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}





%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk “USB 3.1 yang sesungguhnya”, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat “\textit{self synchronizing}” yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}












