    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã?Â¢Ã¢?Â¬Ã??USB 3.1 yang sesungguhnyaÃ?Â¢Ã¢?Â¬Ã¯Â¿Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã?Â¢Ã¢?Â¬Ã??\textit{self synchronizing}Ã?Â¢Ã¢?Â¬Ã¯Â¿Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






%versi 3 (22-07-2020)
\chapter{analisis}


\section{Eksplorasi Library PreonVM}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan \textit{Class library} yang disediakan oleh Virtenio ini cukup banyak. Berikut merupakan contoh program yang menggunakan kelas \textit{package} dari Virtenio yang berhubungan dengan penelitian ini:
\begin{itemize}
    \item USARTExample.java \newline
     Contoh program ini adalah suatu contoh tentang bagaimana cara untuk membuat \textit{interface} agar dapat menguji sebuah aktivasi USART namun pada saat proses \textit{write} dan \textit{read} masih dilakukan secara satu per satu. Berikut merupakan potongan kode pada saat menginisiasi USART.
    \begin{lstlisting}
        import com.virtenio.io.Console;
        import com.virtenio.driver.usart.USARTParams;
    	private USART configUSART() {
    		Console console = new Console();
    
    		int instanceID = console.readInt("Enter the USART port (0=STD, 1=EXT1, 2=EXT2)", 0, 2);
    		int config = console.readInt("Enter the baud rate (\n" + "0=9600, 1=19200, 2=38400, 3=115200, 4=250000)", 0, 4);
    
    		USARTParams params = null;
    
    		switch (config) {
    			case 0:
    				params = USARTConstants.PARAMS_09600;
    				break;
    			case 1:
    				params = USARTConstants.PARAMS_19200;
    				break;
    			case 2:
    				params = USARTConstants.PARAMS_38400;
    				break;
    			case 3:
    				params = USARTConstants.PARAMS_115200;
    				break;
    			case 4:
    				params = USARTConstants.PARAMS_250000;
    				break;
    			default:
    				params = USARTConstants.PARAMS_115200;
    				break;
    		}
    \end{lstlisting}
      Dalam kode ini terdapat 2 variable, variable pertama yaitu instanceID untuk menentukan port dari USART (0=STD, 1=EXT1, 2=EXT2) dan variable ke 2 yaitu \textit{config} untuk menentukan baud rate yang akan digunakan (0=9600, 1=19200, 2=38400, 3=115200, atau 4=250000). Inisiasi params dari USARTParam dengan dengan nilai awal \textit{null} lalu sesuaikan params dengan \textit{baudrate} yang sudah ditentukan pada variable config.  
    \begin{lstlisting}
        import com.virtenio.driver.usart.NativeUSART;
        import com.virtenio.driver.usart.USART;
        import com.virtenio.driver.usart.USARTException;
        import com.virtenio.preon32.examples.common.USARTConstants;
    		
    		NativeUSART usart = NativeUSART.getInstance(instanceID);
    		try {
    			usart.close();
    			usart.open(params);
    			return usart;
    		} catch (Exception e) {
    			return null;
    		}
    	}
    \end{lstlisting}
    Potongan kode diatas terdapat variable usart untuk menginisiasi \textit{Native driver} untuk USART \textit{instances} dengan menggunakan parameter instanceID yang sudah ditentukan sebelumnya. Selanjutnya dengan menggunakan statement \textit{try catch} untuk membuka \textit{instance} USART dengan cara memanggil \textit{method} close() terlebih dahulu lalu memanggil \textit{method} open(params) dengan paramater params yang sudah ditentukan sebelumnya jika tidak terjadi \textit{error} mengembalikan usart jika terjadi \textit{error} mengembalikan \textit{null}.
    \begin{lstlisting}
    	public void reader() {
    		if (usart != null) {
    			byte[] buffer = new byte[64];
    			for (;;) {
    				try {
    					int num = usart.read(buffer);
    					usart.write(buffer, 0, num);
    					usart.flush();
    					System.out.print(new String(buffer, 0, num));
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    	 Potongan kode program diatas digunakan untuk membaca \textit{byte} dari perangkat USART. Jumlah \textit{byte} maksimum untuk dibaca adalah panjang \textit{buffer}. Metode ini memblokir hingga beberapa data dapat dibaca atau terjadi batas waktu. 
    \begin{lstlisting}
    	public void writer() {
    		if (usart != null) {
    			for (int i = 0; i < 10; i++) {
    				try {
    					String str = "Hello USART(" + i + ")\n";
    					usart.write(str.getBytes());
    					usart.flush();
    					System.out.print("write: " + str);
    					Thread.sleep(1000);
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menulis satu \textit{byte} ke perangkat USART, dengan cara memanggil \textit{method} write(b) dengan parameter b untuk menentukan data \textit{byte} untuk menulis.
   
    \begin{lstlisting}
    	public void run() {
    		new Thread() {
    			public void run() {
    				reader();
    			}
    		}.start();
    
    		writer();
    
    		System.out.flush();
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menjalankan keseluruhan kode diatas dengan memanggil \textit{method} reader() dan writer() lalu dikeluarkan dengan \textit{method} flush() agar menjamin bahwa data terakhir yang telah ditulis benar-benar keluar ke \textit{file}.
   \item SerialFlashExample.java \newline
   Potongan kode program ini dapat digunakan untuk mengetahui kapasitas memori Flash dengan memanggil \textit{method} getSectorSize().
   \begin{lstlisting}
       import com.virtenio.driver.flash.Flash;
       public static void main(String[] args) throws Exception {
		System.out.println("TEST FLASH");
		Flash flash = Node.getInstance().getFlash();
		flash.open();
		flash.getSectorSize();
		}
   \end{lstlisting}
   
   \item Handler.java \newline
   Potongan kode program dibawah ini digunakan untuk memulai koneksi memanggil \textit{method} yang dimiliki oleh com.virtenio.commander.toolsets.preon32.Preon32Helper dengan cara membuat objek baru demgam nama nodeHelper dari class Preon32Helper dengan parameter(COM, baudrate) dan dengan memanggil method yang dimiliki dari com.virtenio.commander.io.DataConnection dengan di awali dengan membuat objek baru dengan nama conn dari DataConnection dengan memanggil method nodeHelper.runModule(String) yang dimiliki oleh nodeHelper dengan parameter(nama \textit{sensor node}) setelah itu digunakan sebuah method conn.flush() untuk menghapus perangkat USART dan conn.write(int) untuk mulai menulis input 1 byte kedalam USART. 

   \begin{lstlisting}
        import com.virtenio.commander.io.DataConnection;
        import com.virtenio.commander.toolsets.preon32.Preon32Helper;
        public void init() throws Exception {
		try {
            Preon32Helper nodeHelper = new Preon32Helper("COM8", 115200);
			DataConnection conn = nodeHelper.runModule("basestation");
			BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
			int choiceentry = -1;
			scanner = new Scanner(System.in);
			conn.flush();
			do {
				try {
					choiceentry = scanner.nextInt();
					conn.write(choiceentry);
				}}}}
   \end{lstlisting}
  
\end{itemize}

\section{Deskripsi Perangkat Lunak}
Pada skripsi ini akan dibangun sebuah aplikasi atau sebuah API yang dapat dipanggil untuk menulis dan membaca \textit{file} secara sekaligus dari komputer ke \textit{sensor node} Preon32 ataupun sebaliknya melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan menggunakan \textit{class library} yang disediakan oleh Virtenio. Untuk memperjelas gambaran perangkat lunak yang akan dibangun, dapat dilihat pada gambar \ref{fig:arsitekturPL} yang menunjukkan bagaimana alur komunikasi yang terjadi pada perangkat lunak yang dibangun.
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Arsitektur Perangkat Lunak.png}
    \caption{Arsitektur Perangkat Lunak}
    \label{fig:arsitekturPL}
\end{figure}

Aplikasi ini memiliki beberapa fitur, dengan fitur utama pada aplikasi ini adalah menulis dan membaca \textit{file} secara sekaligus. Fitur lain pada aplikasi ini adalah sebagai berikut:
\begin{enumerate}
    \item Melihat komponen \textit{sensor node}.
    \item Melihat kapasitas memori Flash Preon32.
    \item Membuka dan menginisiasi COM.
   
\end{enumerate}

Fitur melihat komponen \textit{sensor node} untuk membantu pengguna dalam mengetahui komponen apa saja yang ada di dalam \textit{sensor node}. 

Fitur melihat kapasitas memori Flash Preon32 digunakan untuk melihat kapasitas memori yang ada di Flash sehingga pengguna dapat mengetahui sisa memori yang tersedia dalam Flash.

Fitur membuka dan menginisiasi COM digunakan agar pengguna dapat langsung melihat dan menginisiasi COM yang tersambung untuk saling berkomunikasi dan bertukar data antara komputer dengan Preon32. Fungsi lain ini dijelaskan menggunakan diagram \textit{use case} pada Gambar dan skenario pada Tabel \ref{COM} sampai Tabel \ref{Exit}.

\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Use Case Skripsi.png}
    \caption{Diagram \textit{use case} Aplikasi Baca Tulis \textit{File}}
    \label{fig:usecase}
\end{figure}
\newpage
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Membuka Dan Menginisiasi COM \\ 
\hline
Deskripsi & Memudahkan pengguna untuk melihat, membuka dan menginisiasi COM pada saat \textit{sensor node} disambungkan dengan komputer  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} COM"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} COM".
    \item Sistem menampilkan keterangan mengenain COM.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{COM}
\caption{Tabel skenario Membuka Dan Menginisiasi COM}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Komponen Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna dalam hal mengetahui komponen apa saja yang ada di dalam \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} Komponen"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} Komponen".
    \item Sistem menampilkan keterangan mengenai komponen \textit{sensor node} yang menyala.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Check}
\caption{Tabel skenario Melihat Komponen Node Sensor.}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Upload File} \\ 
\hline
Deskripsi & Pengguna dapat mengunggah \textit{file} dari atau ke \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Upload File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Upload File}".
    \item Pengguna memasukkan \textit{file}.
    \item Pengguna menekan tombol "\textit{Upload}".
    \item Sistem menampilkan status "\textit{Success}".
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Upload}
\caption{Tabel skenario \textit{Upload File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Download File} \\ 
\hline
Deskripsi & Pengguna dapat mengunduh \textit{file} dari atau di \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Download File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Download File}".
    \item Sistem menampilkan data.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Download}
\caption{Tabel skenario \textit{Download File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Kapasitas Memori Flash \\ 
\hline
Deskripsi & Membantu pengguna mengetahui sisa memori yang tersedia dalam Flash.  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check Memori Flash}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih \textit{"Check Memori Flash"}.
    \item Sistem menampilkan keterangan mengenai kapasitas memori Flash.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Flash}
\caption{Tabel skenario Melihat Kapasitas Memori Flash}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Restart} Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna untuk \textit{restart} \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Restart} Node Sensor"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Restart} Node Sensor".
    \item Sistem menyalakan ulang \textit{sensor node}.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Restart}
\caption{Tabel skenario \textit{Restart} Node Sensor}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Mematikan Aplikasi \\ 
\hline
Deskripsi & Membantu pengguna untuk mematikan program dan keluar dari aplikasi  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sedang dijalankan dan pengguna memilih "\textit{Exit}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna menjalankan fitur yang ada.
    \item Pengguna memilih "\textit{Exit}".
    \item Sistem menyalakan \textit{sensor node}.
    \item Sistem keluar dari aplikasi dan aplikasi berhenti berjalan.
\end{enumerate} \\
\hline
\end{tabular}
\label{Exit}
\caption{Tabel skenario Mematikan Aplikasi}
\end{table}

Pada subbab ini dibuat suatu diagram kelas sederhana untuk menjelaskan kelas-kelas yang dibutuhkan dalam membangun aplikasi baca tulis \textit{file}. Aplikasi ini dibangun di PC dengan menggunakan Eclipse IDE dan menggunakan Sandbox yang sudah disediakan oleh Virtenio. Aplikasi yang dibuat terdiri dari program pada \textit{base station} dan program GUI untuk menghubungkan \textit{base station} dengan komputer pengguna.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/BS.png}
    \caption{Diagram Kelas Sederhana untuk \textit{base-station}}
    \label{fig:dkbs}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/GUI.png}
    \caption{Diagram Kelas Sederhana untuk GUI}
    \label{fig:dkgui}
\end{figure}
\newpage
Berikut adalah penjelasan dari kelas-kelas pada diagram pada Gambar \ref{fig:dkbs} dan Gambar \ref{fig:dkgui}.
\begin{itemize}
        \item Kelas BS \newline
        Kelas ini untuk menangani fungsi-fungsi yang ada pada \textit{base station}.
        \item Kelas USART \newline
        Kelas ini untuk membuat koneksi antara \textit{base station} atau \textit{sensor node} Preon32 dengan komputer pengguna.
        \item Kelas Display \newline
        Kelas ini digunakan sebagai \textit{interface} untuk pengguna seperti menampilkan komponen \textit{sensor node}.
        \item Kelas Main \newline
        Kelas ini memiliki sebuah \textit{method} untuk me-\textit{restart} \textit{sensor node}, mengirim dan mengunduh \textit{file}, melihat COM, melihat kapasitas memori, dan mematikan aplikasi.
        \item Kelas DataProcess \newline
        Kelas ini digunakan untuk mengambil data dari \textit{base station} yang akan diproses sebelum ditampilkan menjadi bentuk visual di kelas Display.
\end{itemize}

Gambar \ref{fig:flowchart} menggambarkan alur kerja aplikasi dan alur interaksi pengguna dengan aplikasi. Berikut penjelasan dari Gambar \ref{fig:flowchart}:
\begin{enumerate}
    \item Pengguna membuka aplikasi dan aplikasi berjalan.
    \item Pengguna memilih \textit{port} COM dan \textit{baudrate} yang sesuai.
    \item Pengguna dapat menginput 1 untuk menampilkan komponen \textit{sensor node}.
    \item Pengguna dapat menginput 2 untuk melakukan \textit{upload file}.
    \item Pengguna dapat menginput 3 untuk melakukan \textit{download file}.
    \item Pengguna dapat menginput 4 untuk menampikan kapasitas \textit{storage}.
    \item Pengguna dapat melakukan \textit{restart} untuk menyalakan kembali \textit{sensor node}.
\end{enumerate}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Flowchart Skripsi.png}
    \caption{Flowchart Cara Kerja Aplikasi}
    \label{fig:flowchart}
\end{figure}
Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.



USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.

File ke 1
Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file dari file ke 2
Preon32
Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.



%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã?Â¢Ã¢?Â¬Ã??USB 3.1 yang sesungguhnyaÃ?Â¢Ã¢?Â¬Ã¯Â¿Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã?Â¢Ã¢?Â¬Ã??\textit{self synchronizing}Ã?Â¢Ã¢?Â¬Ã¯Â¿Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã?Â¢Ã¢?Â¬Ã??USB 3.1 yang sesungguhnyaÃ?Â¢Ã¢?Â¬Ã¯Â¿Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã?Â¢Ã¢?Â¬Ã??\textit{self synchronizing}Ã?Â¢Ã¢?Â¬Ã¯Â¿Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.



%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???USB 3.1 yang sesungguhnyaÃ??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???\textit{self synchronizing}Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






%versi 3 (22-07-2020)
\chapter{analisis}


\section{Eksplorasi Library PreonVM}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan \textit{Class library} yang disediakan oleh Virtenio ini cukup banyak. Berikut merupakan contoh program yang menggunakan kelas \textit{package} dari Virtenio yang berhubungan dengan penelitian ini:
\begin{itemize}
    \item USARTExample.java \newline
     Contoh program ini adalah suatu contoh tentang bagaimana cara untuk membuat \textit{interface} agar dapat menguji sebuah aktivasi USART namun pada saat proses \textit{write} dan \textit{read} masih dilakukan secara satu per satu. Berikut merupakan potongan kode pada saat menginisiasi USART.
    \begin{lstlisting}
        import com.virtenio.io.Console;
        import com.virtenio.driver.usart.USARTParams;
    	private USART configUSART() {
    		Console console = new Console();
    
    		int instanceID = console.readInt("Enter the USART port (0=STD, 1=EXT1, 2=EXT2)", 0, 2);
    		int config = console.readInt("Enter the baud rate (\n" + "0=9600, 1=19200, 2=38400, 3=115200, 4=250000)", 0, 4);
    
    		USARTParams params = null;
    
    		switch (config) {
    			case 0:
    				params = USARTConstants.PARAMS_09600;
    				break;
    			case 1:
    				params = USARTConstants.PARAMS_19200;
    				break;
    			case 2:
    				params = USARTConstants.PARAMS_38400;
    				break;
    			case 3:
    				params = USARTConstants.PARAMS_115200;
    				break;
    			case 4:
    				params = USARTConstants.PARAMS_250000;
    				break;
    			default:
    				params = USARTConstants.PARAMS_115200;
    				break;
    		}
    \end{lstlisting}
      Dalam kode ini terdapat 2 variable, variable pertama yaitu instanceID untuk menentukan port dari USART (0=STD, 1=EXT1, 2=EXT2) dan variable ke 2 yaitu \textit{config} untuk menentukan baud rate yang akan digunakan (0=9600, 1=19200, 2=38400, 3=115200, atau 4=250000). Inisiasi params dari USARTParam dengan dengan nilai awal \textit{null} lalu sesuaikan params dengan \textit{baudrate} yang sudah ditentukan pada variable config.  
    \begin{lstlisting}
        import com.virtenio.driver.usart.NativeUSART;
        import com.virtenio.driver.usart.USART;
        import com.virtenio.driver.usart.USARTException;
        import com.virtenio.preon32.examples.common.USARTConstants;
    		
    		NativeUSART usart = NativeUSART.getInstance(instanceID);
    		try {
    			usart.close();
    			usart.open(params);
    			return usart;
    		} catch (Exception e) {
    			return null;
    		}
    	}
    \end{lstlisting}
    Potongan kode diatas terdapat variable usart untuk menginisiasi \textit{Native driver} untuk USART \textit{instances} dengan menggunakan parameter instanceID yang sudah ditentukan sebelumnya. Selanjutnya dengan menggunakan statement \textit{try catch} untuk membuka \textit{instance} USART dengan cara memanggil \textit{method} close() terlebih dahulu lalu memanggil \textit{method} open(params) dengan paramater params yang sudah ditentukan sebelumnya jika tidak terjadi \textit{error} mengembalikan usart jika terjadi \textit{error} mengembalikan \textit{null}.
    \begin{lstlisting}
    	public void reader() {
    		if (usart != null) {
    			byte[] buffer = new byte[64];
    			for (;;) {
    				try {
    					int num = usart.read(buffer);
    					usart.write(buffer, 0, num);
    					usart.flush();
    					System.out.print(new String(buffer, 0, num));
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    	 Potongan kode program diatas digunakan untuk membaca \textit{byte} dari perangkat USART. Jumlah \textit{byte} maksimum untuk dibaca adalah panjang \textit{buffer}. Metode ini memblokir hingga beberapa data dapat dibaca atau terjadi batas waktu. 
    \begin{lstlisting}
    	public void writer() {
    		if (usart != null) {
    			for (int i = 0; i < 10; i++) {
    				try {
    					String str = "Hello USART(" + i + ")\n";
    					usart.write(str.getBytes());
    					usart.flush();
    					System.out.print("write: " + str);
    					Thread.sleep(1000);
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menulis satu \textit{byte} ke perangkat USART, dengan cara memanggil \textit{method} write(b) dengan parameter b untuk menentukan data \textit{byte} untuk menulis.
   
    \begin{lstlisting}
    	public void run() {
    		new Thread() {
    			public void run() {
    				reader();
    			}
    		}.start();
    
    		writer();
    
    		System.out.flush();
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menjalankan keseluruhan kode diatas dengan memanggil \textit{method} reader() dan writer() lalu dikeluarkan dengan \textit{method} flush() agar menjamin bahwa data terakhir yang telah ditulis benar-benar keluar ke \textit{file}.
   \item SerialFlashExample.java \newline
   Potongan kode program ini dapat digunakan untuk mengetahui kapasitas memori Flash dengan memanggil \textit{method} getSectorSize().
   \begin{lstlisting}
       import com.virtenio.driver.flash.Flash;
       public static void main(String[] args) throws Exception {
		System.out.println("TEST FLASH");
		Flash flash = Node.getInstance().getFlash();
		flash.open();
		flash.getSectorSize();
		}
   \end{lstlisting}
   
   \item Handler.java \newline
   Potongan kode program dibawah ini digunakan untuk memulai koneksi memanggil \textit{method} yang dimiliki oleh com.virtenio.commander.toolsets.preon32.Preon32Helper dengan cara membuat objek baru demgam nama nodeHelper dari class Preon32Helper dengan parameter(COM, baudrate) dan dengan memanggil method yang dimiliki dari com.virtenio.commander.io.DataConnection dengan di awali dengan membuat objek baru dengan nama conn dari DataConnection dengan memanggil method nodeHelper.runModule(String) yang dimiliki oleh nodeHelper dengan parameter(nama \textit{sensor node}) setelah itu digunakan sebuah method conn.flush() untuk menghapus perangkat USART dan conn.write(int) untuk mulai menulis input 1 byte kedalam USART. 

   \begin{lstlisting}
        import com.virtenio.commander.io.DataConnection;
        import com.virtenio.commander.toolsets.preon32.Preon32Helper;
        public void init() throws Exception {
		try {
            Preon32Helper nodeHelper = new Preon32Helper("COM8", 115200);
			DataConnection conn = nodeHelper.runModule("basestation");
			BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
			int choiceentry = -1;
			scanner = new Scanner(System.in);
			conn.flush();
			do {
				try {
					choiceentry = scanner.nextInt();
					conn.write(choiceentry);
				}}}}
   \end{lstlisting}
  
\end{itemize}

\section{Deskripsi Perangkat Lunak}
Pada skripsi ini akan dibangun sebuah aplikasi atau sebuah API yang dapat dipanggil untuk menulis dan membaca \textit{file} secara sekaligus dari komputer ke \textit{sensor node} Preon32 ataupun sebaliknya melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan menggunakan \textit{class library} yang disediakan oleh Virtenio. Untuk memperjelas gambaran perangkat lunak yang akan dibangun, dapat dilihat pada gambar \ref{fig:arsitekturPL} yang menunjukkan bagaimana alur komunikasi yang terjadi pada perangkat lunak yang dibangun.
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Arsitektur Perangkat Lunak.png}
    \caption{Arsitektur Perangkat Lunak}
    \label{fig:arsitekturPL}
\end{figure}

Aplikasi ini memiliki beberapa fitur, dengan fitur utama pada aplikasi ini adalah menulis dan membaca \textit{file} secara sekaligus. Fitur lain pada aplikasi ini adalah sebagai berikut:
\begin{enumerate}
    \item Melihat komponen \textit{sensor node}.
    \item Melihat kapasitas memori Flash Preon32.
    \item Membuka dan menginisiasi COM.
   
\end{enumerate}

Fitur melihat komponen \textit{sensor node} untuk membantu pengguna dalam mengetahui komponen apa saja yang ada di dalam \textit{sensor node}. 

Fitur melihat kapasitas memori Flash Preon32 digunakan untuk melihat kapasitas memori yang ada di Flash sehingga pengguna dapat mengetahui sisa memori yang tersedia dalam Flash.

Fitur membuka dan menginisiasi COM digunakan agar pengguna dapat langsung melihat dan menginisiasi COM yang tersambung untuk saling berkomunikasi dan bertukar data antara komputer dengan Preon32. Fungsi lain ini dijelaskan menggunakan diagram \textit{use case} pada Gambar dan skenario pada Tabel \ref{COM} sampai Tabel \ref{Exit}.

\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Use Case Skripsi.png}
    \caption{Diagram \textit{use case} Aplikasi Baca Tulis \textit{File}}
    \label{fig:usecase}
\end{figure}
\newpage
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Membuka Dan Menginisiasi COM \\ 
\hline
Deskripsi & Memudahkan pengguna untuk melihat, membuka dan menginisiasi COM pada saat \textit{sensor node} disambungkan dengan komputer  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} COM"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} COM".
    \item Sistem menampilkan keterangan mengenain COM.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{COM}
\caption{Tabel skenario Membuka Dan Menginisiasi COM}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Komponen Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna dalam hal mengetahui komponen apa saja yang ada di dalam \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} Komponen"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} Komponen".
    \item Sistem menampilkan keterangan mengenai komponen \textit{sensor node} yang menyala.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Check}
\caption{Tabel skenario Melihat Komponen Node Sensor.}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Upload File} \\ 
\hline
Deskripsi & Pengguna dapat mengunggah \textit{file} dari atau ke \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Upload File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Upload File}".
    \item Pengguna memasukkan \textit{file}.
    \item Pengguna menekan tombol "\textit{Upload}".
    \item Sistem menampilkan status "\textit{Success}".
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Upload}
\caption{Tabel skenario \textit{Upload File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Download File} \\ 
\hline
Deskripsi & Pengguna dapat mengunduh \textit{file} dari atau di \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Download File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Download File}".
    \item Sistem menampilkan data.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Download}
\caption{Tabel skenario \textit{Download File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Kapasitas Memori Flash \\ 
\hline
Deskripsi & Membantu pengguna mengetahui sisa memori yang tersedia dalam Flash.  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check Memori Flash}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih \textit{"Check Memori Flash"}.
    \item Sistem menampilkan keterangan mengenai kapasitas memori Flash.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Flash}
\caption{Tabel skenario Melihat Kapasitas Memori Flash}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Restart} Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna untuk \textit{restart} \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Restart} Node Sensor"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Restart} Node Sensor".
    \item Sistem menyalakan ulang \textit{sensor node}.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Restart}
\caption{Tabel skenario \textit{Restart} Node Sensor}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Mematikan Aplikasi \\ 
\hline
Deskripsi & Membantu pengguna untuk mematikan program dan keluar dari aplikasi  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sedang dijalankan dan pengguna memilih "\textit{Exit}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna menjalankan fitur yang ada.
    \item Pengguna memilih "\textit{Exit}".
    \item Sistem menyalakan \textit{sensor node}.
    \item Sistem keluar dari aplikasi dan aplikasi berhenti berjalan.
\end{enumerate} \\
\hline
\end{tabular}
\label{Exit}
\caption{Tabel skenario Mematikan Aplikasi}
\end{table}

Pada subbab ini dibuat suatu diagram kelas sederhana untuk menjelaskan kelas-kelas yang dibutuhkan dalam membangun aplikasi baca tulis \textit{file}. Aplikasi ini dibangun di PC dengan menggunakan Eclipse IDE dan menggunakan Sandbox yang sudah disediakan oleh Virtenio. Aplikasi yang dibuat terdiri dari program pada \textit{base station} dan program GUI untuk menghubungkan \textit{base station} dengan komputer pengguna.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/BS.png}
    \caption{Diagram Kelas Sederhana untuk \textit{base-station}}
    \label{fig:dkbs}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/GUI.png}
    \caption{Diagram Kelas Sederhana untuk GUI}
    \label{fig:dkgui}
\end{figure}
\newpage
Berikut adalah penjelasan dari kelas-kelas pada diagram pada Gambar \ref{fig:dkbs} dan Gambar \ref{fig:dkgui}.
\begin{itemize}
        \item Kelas BS \newline
        Kelas ini untuk menangani fungsi-fungsi yang ada pada \textit{base station}.
        \item Kelas USART \newline
        Kelas ini untuk membuat koneksi antara \textit{base station} atau \textit{sensor node} Preon32 dengan komputer pengguna.
        \item Kelas Display \newline
        Kelas ini digunakan sebagai \textit{interface} untuk pengguna seperti menampilkan komponen \textit{sensor node}.
        \item Kelas Main \newline
        Kelas ini memiliki sebuah \textit{method} untuk me-\textit{restart} \textit{sensor node}, mengirim dan mengunduh \textit{file}, melihat COM, melihat kapasitas memori, dan mematikan aplikasi.
        \item Kelas DataProcess \newline
        Kelas ini digunakan untuk mengambil data dari \textit{base station} yang akan diproses sebelum ditampilkan menjadi bentuk visual di kelas Display.
\end{itemize}

Gambar \ref{fig:flowchart} menggambarkan alur kerja aplikasi dan alur interaksi pengguna dengan aplikasi. Berikut penjelasan dari Gambar \ref{fig:flowchart}:
\begin{enumerate}
    \item Pengguna membuka aplikasi dan aplikasi berjalan.
    \item Pengguna memilih \textit{port} COM dan \textit{baudrate} yang sesuai.
    \item Pengguna dapat menginput 1 untuk menampilkan komponen \textit{sensor node}.
    \item Pengguna dapat menginput 2 untuk melakukan \textit{upload file}.
    \item Pengguna dapat menginput 3 untuk melakukan \textit{download file}.
    \item Pengguna dapat menginput 4 untuk menampikan kapasitas \textit{storage}.
    \item Pengguna dapat melakukan \textit{restart} untuk menyalakan kembali \textit{sensor node}.
\end{enumerate}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Flowchart Skripsi.png}
    \caption{Flowchart Cara Kerja Aplikasi}
    \label{fig:flowchart}
\end{figure}
Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.



USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.

File ke 1
Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file dari file ke 2
Preon32
Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.



%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???USB 3.1 yang sesungguhnyaÃ??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???\textit{self synchronizing}Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???USB 3.1 yang sesungguhnyaÃ??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???\textit{self synchronizing}Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.




%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???USB 3.1 yang sesungguhnyaÃ??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???\textit{self synchronizing}Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






%versi 3 (22-07-2020)
\chapter{analisis}


\section{Eksplorasi Library PreonVM}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan \textit{Class library} yang disediakan oleh Virtenio ini cukup banyak. Berikut merupakan contoh program yang menggunakan kelas \textit{package} dari Virtenio yang berhubungan dengan penelitian ini:
\begin{itemize}
    \item USARTExample.java \newline
     Contoh program ini adalah suatu contoh tentang bagaimana cara untuk membuat \textit{interface} agar dapat menguji sebuah aktivasi USART namun pada saat proses \textit{write} dan \textit{read} masih dilakukan secara satu per satu. Berikut merupakan potongan kode pada saat menginisiasi USART.
    \begin{lstlisting}
        import com.virtenio.io.Console;
        import com.virtenio.driver.usart.USARTParams;
    	private USART configUSART() {
    		Console console = new Console();
    
    		int instanceID = console.readInt("Enter the USART port (0=STD, 1=EXT1, 2=EXT2)", 0, 2);
    		int config = console.readInt("Enter the baud rate (\n" + "0=9600, 1=19200, 2=38400, 3=115200, 4=250000)", 0, 4);
    
    		USARTParams params = null;
    
    		switch (config) {
    			case 0:
    				params = USARTConstants.PARAMS_09600;
    				break;
    			case 1:
    				params = USARTConstants.PARAMS_19200;
    				break;
    			case 2:
    				params = USARTConstants.PARAMS_38400;
    				break;
    			case 3:
    				params = USARTConstants.PARAMS_115200;
    				break;
    			case 4:
    				params = USARTConstants.PARAMS_250000;
    				break;
    			default:
    				params = USARTConstants.PARAMS_115200;
    				break;
    		}
    \end{lstlisting}
      Dalam kode ini terdapat 2 variable, variable pertama yaitu instanceID untuk menentukan port dari USART (0=STD, 1=EXT1, 2=EXT2) dan variable ke 2 yaitu \textit{config} untuk menentukan baud rate yang akan digunakan (0=9600, 1=19200, 2=38400, 3=115200, atau 4=250000). Inisiasi params dari USARTParam dengan dengan nilai awal \textit{null} lalu sesuaikan params dengan \textit{baudrate} yang sudah ditentukan pada variable config.  
    \begin{lstlisting}
        import com.virtenio.driver.usart.NativeUSART;
        import com.virtenio.driver.usart.USART;
        import com.virtenio.driver.usart.USARTException;
        import com.virtenio.preon32.examples.common.USARTConstants;
    		
    		NativeUSART usart = NativeUSART.getInstance(instanceID);
    		try {
    			usart.close();
    			usart.open(params);
    			return usart;
    		} catch (Exception e) {
    			return null;
    		}
    	}
    \end{lstlisting}
    Potongan kode diatas terdapat variable usart untuk menginisiasi \textit{Native driver} untuk USART \textit{instances} dengan menggunakan parameter instanceID yang sudah ditentukan sebelumnya. Selanjutnya dengan menggunakan statement \textit{try catch} untuk membuka \textit{instance} USART dengan cara memanggil \textit{method} close() terlebih dahulu lalu memanggil \textit{method} open(params) dengan paramater params yang sudah ditentukan sebelumnya jika tidak terjadi \textit{error} mengembalikan usart jika terjadi \textit{error} mengembalikan \textit{null}.
    \begin{lstlisting}
    	public void reader() {
    		if (usart != null) {
    			byte[] buffer = new byte[64];
    			for (;;) {
    				try {
    					int num = usart.read(buffer);
    					usart.write(buffer, 0, num);
    					usart.flush();
    					System.out.print(new String(buffer, 0, num));
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    	 Potongan kode program diatas digunakan untuk membaca \textit{byte} dari perangkat USART. Jumlah \textit{byte} maksimum untuk dibaca adalah panjang \textit{buffer}. Metode ini memblokir hingga beberapa data dapat dibaca atau terjadi batas waktu. 
    \begin{lstlisting}
    	public void writer() {
    		if (usart != null) {
    			for (int i = 0; i < 10; i++) {
    				try {
    					String str = "Hello USART(" + i + ")\n";
    					usart.write(str.getBytes());
    					usart.flush();
    					System.out.print("write: " + str);
    					Thread.sleep(1000);
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menulis satu \textit{byte} ke perangkat USART, dengan cara memanggil \textit{method} write(b) dengan parameter b untuk menentukan data \textit{byte} untuk menulis.
   
    \begin{lstlisting}
    	public void run() {
    		new Thread() {
    			public void run() {
    				reader();
    			}
    		}.start();
    
    		writer();
    
    		System.out.flush();
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menjalankan keseluruhan kode diatas dengan memanggil \textit{method} reader() dan writer() lalu dikeluarkan dengan \textit{method} flush() agar menjamin bahwa data terakhir yang telah ditulis benar-benar keluar ke \textit{file}.
   \item SerialFlashExample.java \newline
   Potongan kode program ini dapat digunakan untuk mengetahui kapasitas memori Flash dengan memanggil \textit{method} getSectorSize().
   \begin{lstlisting}
       import com.virtenio.driver.flash.Flash;
       public static void main(String[] args) throws Exception {
		System.out.println("TEST FLASH");
		Flash flash = Node.getInstance().getFlash();
		flash.open();
		flash.getSectorSize();
		}
   \end{lstlisting}
   
   \item Handler.java \newline
   Potongan kode program dibawah ini digunakan untuk memulai koneksi memanggil \textit{method} yang dimiliki oleh com.virtenio.commander.toolsets.preon32.Preon32Helper dengan cara membuat objek baru demgam nama nodeHelper dari class Preon32Helper dengan parameter(COM, baudrate) dan dengan memanggil method yang dimiliki dari com.virtenio.commander.io.DataConnection dengan di awali dengan membuat objek baru dengan nama conn dari DataConnection dengan memanggil method nodeHelper.runModule(String) yang dimiliki oleh nodeHelper dengan parameter(nama \textit{sensor node}) setelah itu digunakan sebuah method conn.flush() untuk menghapus perangkat USART dan conn.write(int) untuk mulai menulis input 1 byte kedalam USART. 

   \begin{lstlisting}
        import com.virtenio.commander.io.DataConnection;
        import com.virtenio.commander.toolsets.preon32.Preon32Helper;
        public void init() throws Exception {
		try {
            Preon32Helper nodeHelper = new Preon32Helper("COM8", 115200);
			DataConnection conn = nodeHelper.runModule("basestation");
			BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
			int choiceentry = -1;
			scanner = new Scanner(System.in);
			conn.flush();
			do {
				try {
					choiceentry = scanner.nextInt();
					conn.write(choiceentry);
				}}}}
   \end{lstlisting}
  
\end{itemize}

\section{Deskripsi Perangkat Lunak}
Pada skripsi ini akan dibangun sebuah aplikasi atau sebuah API yang dapat dipanggil untuk menulis dan membaca \textit{file} secara sekaligus dari komputer ke \textit{sensor node} Preon32 ataupun sebaliknya melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan menggunakan \textit{class library} yang disediakan oleh Virtenio. Untuk memperjelas gambaran perangkat lunak yang akan dibangun, dapat dilihat pada gambar \ref{fig:arsitekturPL} yang menunjukkan bagaimana alur komunikasi yang terjadi pada perangkat lunak yang dibangun.
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Arsitektur Perangkat Lunak.png}
    \caption{Arsitektur Perangkat Lunak}
    \label{fig:arsitekturPL}
\end{figure}

Aplikasi ini memiliki beberapa fitur, dengan fitur utama pada aplikasi ini adalah menulis dan membaca \textit{file} secara sekaligus. Fitur lain pada aplikasi ini adalah sebagai berikut:
\begin{enumerate}
    \item Melihat komponen \textit{sensor node}.
    \item Melihat kapasitas memori Flash Preon32.
    \item Membuka dan menginisiasi COM.
   
\end{enumerate}

Fitur melihat komponen \textit{sensor node} untuk membantu pengguna dalam mengetahui komponen apa saja yang ada di dalam \textit{sensor node}. 

Fitur melihat kapasitas memori Flash Preon32 digunakan untuk melihat kapasitas memori yang ada di Flash sehingga pengguna dapat mengetahui sisa memori yang tersedia dalam Flash.

Fitur membuka dan menginisiasi COM digunakan agar pengguna dapat langsung melihat dan menginisiasi COM yang tersambung untuk saling berkomunikasi dan bertukar data antara komputer dengan Preon32. Fungsi lain ini dijelaskan menggunakan diagram \textit{use case} pada Gambar dan skenario pada Tabel \ref{COM} sampai Tabel \ref{Exit}.

\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Use Case Skripsi.png}
    \caption{Diagram \textit{use case} Aplikasi Baca Tulis \textit{File}}
    \label{fig:usecase}
\end{figure}
\newpage
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Membuka Dan Menginisiasi COM \\ 
\hline
Deskripsi & Memudahkan pengguna untuk melihat, membuka dan menginisiasi COM pada saat \textit{sensor node} disambungkan dengan komputer  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} COM"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} COM".
    \item Sistem menampilkan keterangan mengenain COM.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{COM}
\caption{Tabel skenario Membuka Dan Menginisiasi COM}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Komponen Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna dalam hal mengetahui komponen apa saja yang ada di dalam \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} Komponen"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} Komponen".
    \item Sistem menampilkan keterangan mengenai komponen \textit{sensor node} yang menyala.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Check}
\caption{Tabel skenario Melihat Komponen Node Sensor.}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Upload File} \\ 
\hline
Deskripsi & Pengguna dapat mengunggah \textit{file} dari atau ke \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Upload File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Upload File}".
    \item Pengguna memasukkan \textit{file}.
    \item Pengguna menekan tombol "\textit{Upload}".
    \item Sistem menampilkan status "\textit{Success}".
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Upload}
\caption{Tabel skenario \textit{Upload File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Download File} \\ 
\hline
Deskripsi & Pengguna dapat mengunduh \textit{file} dari atau di \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Download File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Download File}".
    \item Sistem menampilkan data.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Download}
\caption{Tabel skenario \textit{Download File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Kapasitas Memori Flash \\ 
\hline
Deskripsi & Membantu pengguna mengetahui sisa memori yang tersedia dalam Flash.  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check Memori Flash}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih \textit{"Check Memori Flash"}.
    \item Sistem menampilkan keterangan mengenai kapasitas memori Flash.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Flash}
\caption{Tabel skenario Melihat Kapasitas Memori Flash}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Restart} Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna untuk \textit{restart} \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Restart} Node Sensor"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Restart} Node Sensor".
    \item Sistem menyalakan ulang \textit{sensor node}.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Restart}
\caption{Tabel skenario \textit{Restart} Node Sensor}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Mematikan Aplikasi \\ 
\hline
Deskripsi & Membantu pengguna untuk mematikan program dan keluar dari aplikasi  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sedang dijalankan dan pengguna memilih "\textit{Exit}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna menjalankan fitur yang ada.
    \item Pengguna memilih "\textit{Exit}".
    \item Sistem menyalakan \textit{sensor node}.
    \item Sistem keluar dari aplikasi dan aplikasi berhenti berjalan.
\end{enumerate} \\
\hline
\end{tabular}
\label{Exit}
\caption{Tabel skenario Mematikan Aplikasi}
\end{table}

Pada subbab ini dibuat suatu diagram kelas sederhana untuk menjelaskan kelas-kelas yang dibutuhkan dalam membangun aplikasi baca tulis \textit{file}. Aplikasi ini dibangun di PC dengan menggunakan Eclipse IDE dan menggunakan Sandbox yang sudah disediakan oleh Virtenio. Aplikasi yang dibuat terdiri dari program pada \textit{base station} dan program GUI untuk menghubungkan \textit{base station} dengan komputer pengguna.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/BS.png}
    \caption{Diagram Kelas Sederhana untuk \textit{base-station}}
    \label{fig:dkbs}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/GUI.png}
    \caption{Diagram Kelas Sederhana untuk GUI}
    \label{fig:dkgui}
\end{figure}
\newpage
Berikut adalah penjelasan dari kelas-kelas pada diagram pada Gambar \ref{fig:dkbs} dan Gambar \ref{fig:dkgui}.
\begin{itemize}
        \item Kelas BS \newline
        Kelas ini untuk menangani fungsi-fungsi yang ada pada \textit{base station}.
        \item Kelas USART \newline
        Kelas ini untuk membuat koneksi antara \textit{base station} atau \textit{sensor node} Preon32 dengan komputer pengguna.
        \item Kelas Display \newline
        Kelas ini digunakan sebagai \textit{interface} untuk pengguna seperti menampilkan komponen \textit{sensor node}.
        \item Kelas Main \newline
        Kelas ini memiliki sebuah \textit{method} untuk me-\textit{restart} \textit{sensor node}, mengirim dan mengunduh \textit{file}, melihat COM, melihat kapasitas memori, dan mematikan aplikasi.
        \item Kelas DataProcess \newline
        Kelas ini digunakan untuk mengambil data dari \textit{base station} yang akan diproses sebelum ditampilkan menjadi bentuk visual di kelas Display.
\end{itemize}

Gambar \ref{fig:flowchart} menggambarkan alur kerja aplikasi dan alur interaksi pengguna dengan aplikasi. Berikut penjelasan dari Gambar \ref{fig:flowchart}:
\begin{enumerate}
    \item Pengguna membuka aplikasi dan aplikasi berjalan.
    \item Pengguna memilih \textit{port} COM dan \textit{baudrate} yang sesuai.
    \item Pengguna dapat menginput 1 untuk menampilkan komponen \textit{sensor node}.
    \item Pengguna dapat menginput 2 untuk melakukan \textit{upload file}.
    \item Pengguna dapat menginput 3 untuk melakukan \textit{download file}.
    \item Pengguna dapat menginput 4 untuk menampikan kapasitas \textit{storage}.
    \item Pengguna dapat melakukan \textit{restart} untuk menyalakan kembali \textit{sensor node}.
\end{enumerate}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Flowchart Skripsi.png}
    \caption{Flowchart Cara Kerja Aplikasi}
    \label{fig:flowchart}
\end{figure}
Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.



USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.

File ke 1
Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file dari file ke 2
Preon32
Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.



%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???USB 3.1 yang sesungguhnyaÃ??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???\textit{self synchronizing}Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???USB 3.1 yang sesungguhnyaÃ??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã???\textit{self synchronizing}Ã??Ã?Â¢Ã?Â¢?Ã?Â¬Ã?Â¯Ã?Â¿Ã?Â½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






Bab 1
\chapter{Pendahuluan}
\label{chap:intro}
   
\section{Latar Belakang}
\label{sec:label}

PreonVM adalah sebuah {\it virtual machine} dari Virtenio yang disediakan untuk {\it embedded system} sensor Preon32. {\it Virtual Machine} (VM) ini akan langsung berjalan pada sebuah mikrokontroler dan mendukung operasi sampai dengan 64-{\it bit}. {\it Virtual Machine} (VM) juga memungkinkan mengeksekusi aplikasi standar Java pada Preon32 dan karena itu Virtenio menyediakan {\it library} (API) untuk {\it interface} dan dapat dijalankan oleh Preon32.

{\it Library} Preon32 ini sendiri memiliki banyak {\it package class} yang dapat digunakan dalam sensor maupun yang digunakan dalam berinteraksi dengan sensor melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART). Sinyal analog dapat diambil sampelnya dengan konverter sinyal analog ke sinyal digital yang terintegrasi. Resolusi tinggi 12 \textit{bit} yang dimiliki Preon32 memungkinan laju pengambilan sampel hingga satu juta sampel per detik memisahkan modul Preon32 dari produk pesaing.

Sesuai dengan apa yang saya ketahui dari Bapak Elisati Hulu bahwa selama ini untuk \textit{interface} program dari komputer ke sensor ini langsung menggunakan \textit{library-library} yang disediakan oleh Virtenio dan semua itu sangat terbatas oleh \textit{package - package class} yang tersedia dan ada juga yang langsung dipakai di dalam kode program itu sendiri. Dengan alasan tersebut maka perlu dibangun modul untuk \textit{interface} antara program yang ada di komputer dengan Preon32 yang \textit{attach} ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java dengan bantuan {\it package class} dari \textit{library} yang disediakan oleh Virtenio maupun dengan menambahkan \textit{package class} sehingga memungkinkan kita sebagai pengguna untuk lebih mudah dalam hal membaca dan atau menulis data dari atau ke Preon32 dan memberikan modul - modul yang berkaitan dengan pengecekan speksifikasi dari sensor Preon32.

Pada skripsi ini, akan dibuat sebuah modul {\it interface} antara program yang ada di komputer dengan Preon32 yang tersambung ke komputer melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).



\section{Rumusan Masalah}
\label{sec:rumusan}
Rumusan masalah berdasarkan latar belakang yang sudah dijelaskan yaitu:
\begin{itemize}
    \item Bagaimana melakukan perancangan desain modul \textit{interface} yang mudah dipahami oleh semua tipe \textit{user}?
	\item Bagaimana cara membangun modul \textit{interface} antara komputer dan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART)?
\end{itemize}

\newpage

\section{Tujuan}
\label{sec:tujuan}
Tujuan dari topik ini adalah sebagai berikut:
\begin{itemize}
    \item Mengeksplorasi \textit{library} PreonVM dari Preon32.
    \item Membangun modul {\it interface} yang siap digunakan antara komputer dengan Preon32 melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan program Java.
\end{itemize}

\section{Batasan Masalah}
\label{sec:batasan}
Penelitian ini dibuat berdasarkan batasan-batasan sebagai berikut:
\begin{enumerate}
    %\item Fokus utama penelitian ini adalah mengeksplorasi \textit{PreonVM} dan membangun modul \textit{interface} melalui USB dengan komputer yang baik.
    \item Aplikasi yang dibuat hanya berjalan pada 1 buah \textit{sensor node} terhubung ke komputer melalui USB atau UART.
    \item File yang dikirim kedalam sensor merupakan file .txt.
\end{enumerate}


\section{Metodologi}
\label{sec:metlit}
Berikut ini adalah langkah-langkah yang dilakukan untuk mengerjakan penelitian ini, antara lain:
\begin{enumerate}
    \item Melakukan studi literatur mengenai Preon32, \textit{interface library} PreonVM, \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
    \item Mempelajari cara memvisualisasikan modul \textit{interface} pada perangkat lunak.
    \item Melakukan analisis terhadap perangkat lunak yang dibangun.
    \item Melakukan perancangan untuk perangkat lunak yang dibangun.
    \item Mengimplementasikan perangkat lunak sesuai hasil analisis dan rancangan.
    \item Melakukan pengujian terhadap perangkat lunak.
    \item Menganalisis hasil pengujian yang telah dilakukan.
    \item Membuat dokumentasi dari penelitian pengembangan modul \textit{interface} melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART).
\end{enumerate}

\section{Sistematika Pembahasan}
\label{sec:sispem}
Sistematika pembahasan pada Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer ini adalah:

    Bab 1 memuat pendahuluan yang membahas latar belakang masalah, rumusan masalah, tujuan, batasan masalah, metodologi penelitian yang menjadi acuan penelitian, dan sistematika pembahasan.
    
    Bab 2 memuat dasar teori yang mendukung berjalannya perancangan dan pengembangan Eksplorasi PreonVM dan Membangun Modul Interface USB dengan Komputer. Berisikan dasar teori tentang \textit{Wireless Sensor Network} (WSN), Node Sensor, Preon32, USB, UART dan USART.
    
    Bab 3 memuat analisis yang membahas deskripsi singkat perangkat lunak, analisis kebutuhan perangkat lunak, analisis cara kerja sistem.
    
    Bab 4 memuat perancangan yang membahas perancangan Eksplorasi PreonVM dan Membangun Modul \textit{Interface} USB dengan Komputer. Berisi tentang perancangan modul \textit{interface} secara rinci mengenai fitur-fitur dari perangkat lunak.
    
    Bab 5 memuat implementasi dan pengujian yang membahas implementasi dari hasil rancangan pengujian dari modul \textit{Interface} USB dengan Komputer yang telah dibuat dan pengujian modul yang telah dibuat.
    
    Bab 6 memuat kesimpulan yang membahas kesimpulan dari hasil pengujian dan saran untuk pengembangan selanjutnya.





%versi 3 (22-07-2020)
\chapter{analisis}


\section{Eksplorasi Library PreonVM}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan \textit{Class library} yang disediakan oleh Virtenio ini cukup banyak. Berikut merupakan contoh program yang menggunakan kelas \textit{package} dari Virtenio yang berhubungan dengan penelitian ini:
\begin{itemize}
    \item USARTExample.java \newline
     Contoh program ini adalah suatu contoh tentang bagaimana cara untuk membuat \textit{interface} agar dapat menguji sebuah aktivasi USART namun pada saat proses \textit{write} dan \textit{read} masih dilakukan secara satu per satu. Berikut merupakan potongan kode pada saat menginisiasi USART.
    \begin{lstlisting}
        import com.virtenio.io.Console;
        import com.virtenio.driver.usart.USARTParams;
    	private USART configUSART() {
    		Console console = new Console();
    
    		int instanceID = console.readInt("Enter the USART port (0=STD, 1=EXT1, 2=EXT2)", 0, 2);
    		int config = console.readInt("Enter the baud rate (\n" + "0=9600, 1=19200, 2=38400, 3=115200, 4=250000)", 0, 4);
    
    		USARTParams params = null;
    
    		switch (config) {
    			case 0:
    				params = USARTConstants.PARAMS_09600;
    				break;
    			case 1:
    				params = USARTConstants.PARAMS_19200;
    				break;
    			case 2:
    				params = USARTConstants.PARAMS_38400;
    				break;
    			case 3:
    				params = USARTConstants.PARAMS_115200;
    				break;
    			case 4:
    				params = USARTConstants.PARAMS_250000;
    				break;
    			default:
    				params = USARTConstants.PARAMS_115200;
    				break;
    		}
    \end{lstlisting}
      Dalam kode ini terdapat 2 variable, variable pertama yaitu instanceID untuk menentukan port dari USART (0=STD, 1=EXT1, 2=EXT2) dan variable ke 2 yaitu \textit{config} untuk menentukan baud rate yang akan digunakan (0=9600, 1=19200, 2=38400, 3=115200, atau 4=250000). Inisiasi params dari USARTParam dengan dengan nilai awal \textit{null} lalu sesuaikan params dengan \textit{baudrate} yang sudah ditentukan pada variable config.  
    \begin{lstlisting}
        import com.virtenio.driver.usart.NativeUSART;
        import com.virtenio.driver.usart.USART;
        import com.virtenio.driver.usart.USARTException;
        import com.virtenio.preon32.examples.common.USARTConstants;
    		
    		NativeUSART usart = NativeUSART.getInstance(instanceID);
    		try {
    			usart.close();
    			usart.open(params);
    			return usart;
    		} catch (Exception e) {
    			return null;
    		}
    	}
    \end{lstlisting}
    Potongan kode diatas terdapat variable usart untuk menginisiasi \textit{Native driver} untuk USART \textit{instances} dengan menggunakan parameter instanceID yang sudah ditentukan sebelumnya. Selanjutnya dengan menggunakan statement \textit{try catch} untuk membuka \textit{instance} USART dengan cara memanggil \textit{method} close() terlebih dahulu lalu memanggil \textit{method} open(params) dengan paramater params yang sudah ditentukan sebelumnya jika tidak terjadi \textit{error} mengembalikan usart jika terjadi \textit{error} mengembalikan \textit{null}.
    \begin{lstlisting}
    	public void reader() {
    		if (usart != null) {
    			byte[] buffer = new byte[64];
    			for (;;) {
    				try {
    					int num = usart.read(buffer);
    					usart.write(buffer, 0, num);
    					usart.flush();
    					System.out.print(new String(buffer, 0, num));
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    	 Potongan kode program diatas digunakan untuk membaca \textit{byte} dari perangkat USART. Jumlah \textit{byte} maksimum untuk dibaca adalah panjang \textit{buffer}. Metode ini memblokir hingga beberapa data dapat dibaca atau terjadi batas waktu. 
    \begin{lstlisting}
    	public void writer() {
    		if (usart != null) {
    			for (int i = 0; i < 10; i++) {
    				try {
    					String str = "Hello USART(" + i + ")\n";
    					usart.write(str.getBytes());
    					usart.flush();
    					System.out.print("write: " + str);
    					Thread.sleep(1000);
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menulis satu \textit{byte} ke perangkat USART, dengan cara memanggil \textit{method} write(b) dengan parameter b untuk menentukan data \textit{byte} untuk menulis.
   
    \begin{lstlisting}
    	public void run() {
    		new Thread() {
    			public void run() {
    				reader();
    			}
    		}.start();
    
    		writer();
    
    		System.out.flush();
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menjalankan keseluruhan kode diatas dengan memanggil \textit{method} reader() dan writer() lalu dikeluarkan dengan \textit{method} flush() agar menjamin bahwa data terakhir yang telah ditulis benar-benar keluar ke \textit{file}.
   \item SerialFlashExample.java \newline
   Potongan kode program ini dapat digunakan untuk mengetahui kapasitas memori Flash dengan memanggil \textit{method} getSectorSize().
   \begin{lstlisting}
       import com.virtenio.driver.flash.Flash;
       public static void main(String[] args) throws Exception {
		System.out.println("TEST FLASH");
		Flash flash = Node.getInstance().getFlash();
		flash.open();
		flash.getSectorSize();
		}
   \end{lstlisting}
   
   \item Handler.java \newline
   Potongan kode program dibawah ini digunakan untuk memulai koneksi memanggil \textit{method} yang dimiliki oleh com.virtenio.commander.toolsets.preon32.Preon32Helper dengan cara membuat objek baru demgam nama nodeHelper dari class Preon32Helper dengan parameter(COM, baudrate) dan dengan memanggil method yang dimiliki dari com.virtenio.commander.io.DataConnection dengan di awali dengan membuat objek baru dengan nama conn dari DataConnection dengan memanggil method nodeHelper.runModule(String) yang dimiliki oleh nodeHelper dengan parameter(nama \textit{sensor node}) setelah itu digunakan sebuah method conn.flush() untuk menghapus perangkat USART dan conn.write(int) untuk mulai menulis input 1 byte kedalam USART. 

   \begin{lstlisting}
        import com.virtenio.commander.io.DataConnection;
        import com.virtenio.commander.toolsets.preon32.Preon32Helper;
        public void init() throws Exception {
		try {
            Preon32Helper nodeHelper = new Preon32Helper("COM8", 115200);
			DataConnection conn = nodeHelper.runModule("basestation");
			BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
			int choiceentry = -1;
			scanner = new Scanner(System.in);
			conn.flush();
			do {
				try {
					choiceentry = scanner.nextInt();
					conn.write(choiceentry);
				}}}}
   \end{lstlisting}
  
\end{itemize}

\section{Deskripsi Perangkat Lunak}
Pada skripsi ini akan dibangun sebuah aplikasi atau sebuah API yang dapat dipanggil untuk menulis dan membaca \textit{file} secara sekaligus dari komputer ke \textit{sensor node} Preon32 ataupun sebaliknya melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan menggunakan \textit{class library} yang disediakan oleh Virtenio. Untuk memperjelas gambaran perangkat lunak yang akan dibangun, dapat dilihat pada gambar \ref{fig:arsitekturPL} yang menunjukkan bagaimana alur komunikasi yang terjadi pada perangkat lunak yang dibangun.
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Arsitektur Perangkat Lunak.png}
    \caption{Arsitektur Perangkat Lunak}
    \label{fig:arsitekturPL}
\end{figure}

Aplikasi ini memiliki beberapa fitur, dengan fitur utama pada aplikasi ini adalah menulis dan membaca \textit{file} secara sekaligus. Fitur lain pada aplikasi ini adalah sebagai berikut:
\begin{enumerate}
    \item Melihat komponen \textit{sensor node}.
    \item Melihat kapasitas memori Flash Preon32.
    \item Membuka dan menginisiasi COM.
   
\end{enumerate}

Fitur melihat komponen \textit{sensor node} untuk membantu pengguna dalam mengetahui komponen apa saja yang ada di dalam \textit{sensor node}. 

Fitur melihat kapasitas memori Flash Preon32 digunakan untuk melihat kapasitas memori yang ada di Flash sehingga pengguna dapat mengetahui sisa memori yang tersedia dalam Flash.

Fitur membuka dan menginisiasi COM digunakan agar pengguna dapat langsung melihat dan menginisiasi COM yang tersambung untuk saling berkomunikasi dan bertukar data antara komputer dengan Preon32. Fungsi lain ini dijelaskan menggunakan diagram \textit{use case} pada Gambar dan skenario pada Tabel \ref{COM} sampai Tabel \ref{Exit}.

\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Use Case Skripsi.png}
    \caption{Diagram \textit{use case} Aplikasi Baca Tulis \textit{File}}
    \label{fig:usecase}
\end{figure}
\newpage
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Membuka Dan Menginisiasi COM \\ 
\hline
Deskripsi & Memudahkan pengguna untuk melihat, membuka dan menginisiasi COM pada saat \textit{sensor node} disambungkan dengan komputer  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} COM"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} COM".
    \item Sistem menampilkan keterangan mengenain COM.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{COM}
\caption{Tabel skenario Membuka Dan Menginisiasi COM}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Komponen Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna dalam hal mengetahui komponen apa saja yang ada di dalam \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} Komponen"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} Komponen".
    \item Sistem menampilkan keterangan mengenai komponen \textit{sensor node} yang menyala.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Check}
\caption{Tabel skenario Melihat Komponen Node Sensor.}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Upload File} \\ 
\hline
Deskripsi & Pengguna dapat mengunggah \textit{file} dari atau ke \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Upload File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Upload File}".
    \item Pengguna memasukkan \textit{file}.
    \item Pengguna menekan tombol "\textit{Upload}".
    \item Sistem menampilkan status "\textit{Success}".
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Upload}
\caption{Tabel skenario \textit{Upload File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Download File} \\ 
\hline
Deskripsi & Pengguna dapat mengunduh \textit{file} dari atau di \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Download File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Download File}".
    \item Sistem menampilkan data.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Download}
\caption{Tabel skenario \textit{Download File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Kapasitas Memori Flash \\ 
\hline
Deskripsi & Membantu pengguna mengetahui sisa memori yang tersedia dalam Flash.  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check Memori Flash}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih \textit{"Check Memori Flash"}.
    \item Sistem menampilkan keterangan mengenai kapasitas memori Flash.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Flash}
\caption{Tabel skenario Melihat Kapasitas Memori Flash}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Restart} Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna untuk \textit{restart} \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Restart} Node Sensor"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Restart} Node Sensor".
    \item Sistem menyalakan ulang \textit{sensor node}.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Restart}
\caption{Tabel skenario \textit{Restart} Node Sensor}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Mematikan Aplikasi \\ 
\hline
Deskripsi & Membantu pengguna untuk mematikan program dan keluar dari aplikasi  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sedang dijalankan dan pengguna memilih "\textit{Exit}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna menjalankan fitur yang ada.
    \item Pengguna memilih "\textit{Exit}".
    \item Sistem menyalakan \textit{sensor node}.
    \item Sistem keluar dari aplikasi dan aplikasi berhenti berjalan.
\end{enumerate} \\
\hline
\end{tabular}
\label{Exit}
\caption{Tabel skenario Mematikan Aplikasi}
\end{table}

Pada subbab ini dibuat suatu diagram kelas sederhana untuk menjelaskan kelas-kelas yang dibutuhkan dalam membangun aplikasi baca tulis \textit{file}. Aplikasi ini dibangun di PC dengan menggunakan Eclipse IDE dan menggunakan Sandbox yang sudah disediakan oleh Virtenio. Aplikasi yang dibuat terdiri dari program pada \textit{base station} dan program GUI untuk menghubungkan \textit{base station} dengan komputer pengguna.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/BS.png}
    \caption{Diagram Kelas Sederhana untuk \textit{base-station}}
    \label{fig:dkbs}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/GUI.png}
    \caption{Diagram Kelas Sederhana untuk GUI}
    \label{fig:dkgui}
\end{figure}
\newpage
Berikut adalah penjelasan dari kelas-kelas pada diagram pada Gambar \ref{fig:dkbs} dan Gambar \ref{fig:dkgui}.
\begin{itemize}
        \item Kelas BS \newline
        Kelas ini untuk menangani fungsi-fungsi yang ada pada \textit{base station}.
        \item Kelas USART \newline
        Kelas ini untuk membuat koneksi antara \textit{base station} atau \textit{sensor node} Preon32 dengan komputer pengguna.
        \item Kelas Display \newline
        Kelas ini digunakan sebagai \textit{interface} untuk pengguna seperti menampilkan komponen \textit{sensor node}.
        \item Kelas Main \newline
        Kelas ini memiliki sebuah \textit{method} untuk me-\textit{restart} \textit{sensor node}, mengirim dan mengunduh \textit{file}, melihat COM, melihat kapasitas memori, dan mematikan aplikasi.
        \item Kelas DataProcess \newline
        Kelas ini digunakan untuk mengambil data dari \textit{base station} yang akan diproses sebelum ditampilkan menjadi bentuk visual di kelas Display.
\end{itemize}

Gambar \ref{fig:flowchart} menggambarkan alur kerja aplikasi dan alur interaksi pengguna dengan aplikasi. Berikut penjelasan dari Gambar \ref{fig:flowchart}:
\begin{enumerate}
    \item Pengguna membuka aplikasi dan aplikasi berjalan.
    \item Pengguna memilih \textit{port} COM dan \textit{baudrate} yang sesuai.
    \item Pengguna dapat menginput 1 untuk menampilkan komponen \textit{sensor node}.
    \item Pengguna dapat menginput 2 untuk melakukan \textit{upload file}.
    \item Pengguna dapat menginput 3 untuk melakukan \textit{download file}.
    \item Pengguna dapat menginput 4 untuk menampikan kapasitas \textit{storage}.
    \item Pengguna dapat melakukan \textit{restart} untuk menyalakan kembali \textit{sensor node}.
\end{enumerate}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Flowchart Skripsi.png}
    \caption{Flowchart Cara Kerja Aplikasi}
    \label{fig:flowchart}
\end{figure}
%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã¢â?¬Å?USB 3.1 yang sesungguhnyaÃ¢â?¬ï¿½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã¢â?¬Å?\textit{self synchronizing}Ã¢â?¬ï¿½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}






%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã¢â?¬Å?USB 3.1 yang sesungguhnyaÃ¢â?¬ï¿½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã¢â?¬Å?\textit{self synchronizing}Ã¢â?¬ï¿½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}

%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã¢â?¬Å?USB 3.1 yang sesungguhnyaÃ¢â?¬ï¿½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã¢â?¬Å?\textit{self synchronizing}Ã¢â?¬ï¿½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}





%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã¢â?¬Å?USB 3.1 yang sesungguhnyaÃ¢â?¬ï¿½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã¢â?¬Å?\textit{self synchronizing}Ã¢â?¬ï¿½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}













%versi 3 (22-07-2020)
\chapter{analisis}


\section{Eksplorasi Library PreonVM}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan \textit{Class library} yang disediakan oleh Virtenio ini cukup banyak. Berikut merupakan contoh program yang menggunakan kelas \textit{package} dari Virtenio yang berhubungan dengan penelitian ini:
\begin{itemize}
    \item USARTExample.java \newline
     Contoh program ini adalah suatu contoh tentang bagaimana cara untuk membuat \textit{interface} agar dapat menguji sebuah aktivasi USART namun pada saat proses \textit{write} dan \textit{read} masih dilakukan secara satu per satu. Berikut merupakan potongan kode pada saat menginisiasi USART.
    \begin{lstlisting}
        import com.virtenio.io.Console;
        import com.virtenio.driver.usart.USARTParams;
    	private USART configUSART() {
    		Console console = new Console();
    
    		int instanceID = console.readInt("Enter the USART port (0=STD, 1=EXT1, 2=EXT2)", 0, 2);
    		int config = console.readInt("Enter the baud rate (\n" + "0=9600, 1=19200, 2=38400, 3=115200, 4=250000)", 0, 4);
    
    		USARTParams params = null;
    
    		switch (config) {
    			case 0:
    				params = USARTConstants.PARAMS_09600;
    				break;
    			case 1:
    				params = USARTConstants.PARAMS_19200;
    				break;
    			case 2:
    				params = USARTConstants.PARAMS_38400;
    				break;
    			case 3:
    				params = USARTConstants.PARAMS_115200;
    				break;
    			case 4:
    				params = USARTConstants.PARAMS_250000;
    				break;
    			default:
    				params = USARTConstants.PARAMS_115200;
    				break;
    		}
    \end{lstlisting}
      Dalam kode ini terdapat 2 variable, variable pertama yaitu instanceID untuk menentukan port dari USART (0=STD, 1=EXT1, 2=EXT2) dan variable ke 2 yaitu \textit{config} untuk menentukan baud rate yang akan digunakan (0=9600, 1=19200, 2=38400, 3=115200, atau 4=250000). Inisiasi params dari USARTParam dengan dengan nilai awal \textit{null} lalu sesuaikan params dengan \textit{baudrate} yang sudah ditentukan pada variable config.  
    \begin{lstlisting}
        import com.virtenio.driver.usart.NativeUSART;
        import com.virtenio.driver.usart.USART;
        import com.virtenio.driver.usart.USARTException;
        import com.virtenio.preon32.examples.common.USARTConstants;
    		
    		NativeUSART usart = NativeUSART.getInstance(instanceID);
    		try {
    			usart.close();
    			usart.open(params);
    			return usart;
    		} catch (Exception e) {
    			return null;
    		}
    	}
    \end{lstlisting}
    Potongan kode diatas terdapat variable usart untuk menginisiasi \textit{Native driver} untuk USART \textit{instances} dengan menggunakan parameter instanceID yang sudah ditentukan sebelumnya. Selanjutnya dengan menggunakan statement \textit{try catch} untuk membuka \textit{instance} USART dengan cara memanggil \textit{method} close() terlebih dahulu lalu memanggil \textit{method} open(params) dengan paramater params yang sudah ditentukan sebelumnya jika tidak terjadi \textit{error} mengembalikan usart jika terjadi \textit{error} mengembalikan \textit{null}.
    \begin{lstlisting}
    	public void reader() {
    		if (usart != null) {
    			byte[] buffer = new byte[64];
    			for (;;) {
    				try {
    					int num = usart.read(buffer);
    					usart.write(buffer, 0, num);
    					usart.flush();
    					System.out.print(new String(buffer, 0, num));
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    	 Potongan kode program diatas digunakan untuk membaca \textit{byte} dari perangkat USART. Jumlah \textit{byte} maksimum untuk dibaca adalah panjang \textit{buffer}. Metode ini memblokir hingga beberapa data dapat dibaca atau terjadi batas waktu. 
    \begin{lstlisting}
    	public void writer() {
    		if (usart != null) {
    			for (int i = 0; i < 10; i++) {
    				try {
    					String str = "Hello USART(" + i + ")\n";
    					usart.write(str.getBytes());
    					usart.flush();
    					System.out.print("write: " + str);
    					Thread.sleep(1000);
    				} catch (Exception e) {
    					e.printStackTrace();
    				}
    			}
    		}
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menulis satu \textit{byte} ke perangkat USART, dengan cara memanggil \textit{method} write(b) dengan parameter b untuk menentukan data \textit{byte} untuk menulis.
   
    \begin{lstlisting}
    	public void run() {
    		new Thread() {
    			public void run() {
    				reader();
    			}
    		}.start();
    
    		writer();
    
    		System.out.flush();
    	}
    \end{lstlisting}
    Potongan kode program diatas digunakan untuk menjalankan keseluruhan kode diatas dengan memanggil \textit{method} reader() dan writer() lalu dikeluarkan dengan \textit{method} flush() agar menjamin bahwa data terakhir yang telah ditulis benar-benar keluar ke \textit{file}.
   \item SerialFlashExample.java \newline
   Potongan kode program ini dapat digunakan untuk mengetahui kapasitas memori Flash dengan memanggil \textit{method} getSectorSize().
   \begin{lstlisting}
       import com.virtenio.driver.flash.Flash;
       public static void main(String[] args) throws Exception {
		System.out.println("TEST FLASH");
		Flash flash = Node.getInstance().getFlash();
		flash.open();
		flash.getSectorSize();
		}
   \end{lstlisting}
   
   \item Handler.java \newline
   Potongan kode program dibawah ini digunakan untuk memulai koneksi memanggil \textit{method} yang dimiliki oleh com.virtenio.commander.toolsets.preon32.Preon32Helper dengan cara membuat objek baru demgam nama nodeHelper dari class Preon32Helper dengan parameter(COM, baudrate) dan dengan memanggil method yang dimiliki dari com.virtenio.commander.io.DataConnection dengan di awali dengan membuat objek baru dengan nama conn dari DataConnection dengan memanggil method nodeHelper.runModule(String) yang dimiliki oleh nodeHelper dengan parameter(nama \textit{sensor node}) setelah itu digunakan sebuah method conn.flush() untuk menghapus perangkat USART dan conn.write(int) untuk mulai menulis input 1 byte kedalam USART. 

   \begin{lstlisting}
        import com.virtenio.commander.io.DataConnection;
        import com.virtenio.commander.toolsets.preon32.Preon32Helper;
        public void init() throws Exception {
		try {
            Preon32Helper nodeHelper = new Preon32Helper("COM8", 115200);
			DataConnection conn = nodeHelper.runModule("basestation");
			BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
			int choiceentry = -1;
			scanner = new Scanner(System.in);
			conn.flush();
			do {
				try {
					choiceentry = scanner.nextInt();
					conn.write(choiceentry);
				}}}}
   \end{lstlisting}
  
\end{itemize}

\section{Deskripsi Perangkat Lunak}
Pada skripsi ini akan dibangun sebuah aplikasi atau sebuah API yang dapat dipanggil untuk menulis dan membaca \textit{file} secara sekaligus dari komputer ke \textit{sensor node} Preon32 ataupun sebaliknya melalui \textit{Universal Serial Bus} (USB) atau \textit{Universal Asynchronous Receiver-Transmitter} (UART) dengan menggunakan \textit{class library} yang disediakan oleh Virtenio. Untuk memperjelas gambaran perangkat lunak yang akan dibangun, dapat dilihat pada gambar \ref{fig:arsitekturPL} yang menunjukkan bagaimana alur komunikasi yang terjadi pada perangkat lunak yang dibangun.
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Arsitektur Perangkat Lunak.png}
    \caption{Arsitektur Perangkat Lunak}
    \label{fig:arsitekturPL}
\end{figure}

Aplikasi ini memiliki beberapa fitur, dengan fitur utama pada aplikasi ini adalah menulis dan membaca \textit{file} secara sekaligus. Fitur lain pada aplikasi ini adalah sebagai berikut:
\begin{enumerate}
    \item Melihat komponen \textit{sensor node}.
    \item Melihat kapasitas memori Flash Preon32.
    \item Membuka dan menginisiasi COM.
   
\end{enumerate}

Fitur melihat komponen \textit{sensor node} untuk membantu pengguna dalam mengetahui komponen apa saja yang ada di dalam \textit{sensor node}. 

Fitur melihat kapasitas memori Flash Preon32 digunakan untuk melihat kapasitas memori yang ada di Flash sehingga pengguna dapat mengetahui sisa memori yang tersedia dalam Flash.

Fitur membuka dan menginisiasi COM digunakan agar pengguna dapat langsung melihat dan menginisiasi COM yang tersambung untuk saling berkomunikasi dan bertukar data antara komputer dengan Preon32. Fungsi lain ini dijelaskan menggunakan diagram \textit{use case} pada Gambar dan skenario pada Tabel \ref{COM} sampai Tabel \ref{Exit}.

\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Use Case Skripsi.png}
    \caption{Diagram \textit{use case} Aplikasi Baca Tulis \textit{File}}
    \label{fig:usecase}
\end{figure}
\newpage
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Membuka Dan Menginisiasi COM \\ 
\hline
Deskripsi & Memudahkan pengguna untuk melihat, membuka dan menginisiasi COM pada saat \textit{sensor node} disambungkan dengan komputer  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} COM"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} COM".
    \item Sistem menampilkan keterangan mengenain COM.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{COM}
\caption{Tabel skenario Membuka Dan Menginisiasi COM}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Komponen Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna dalam hal mengetahui komponen apa saja yang ada di dalam \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check} Komponen"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Check} Komponen".
    \item Sistem menampilkan keterangan mengenai komponen \textit{sensor node} yang menyala.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Check}
\caption{Tabel skenario Melihat Komponen Node Sensor.}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Upload File} \\ 
\hline
Deskripsi & Pengguna dapat mengunggah \textit{file} dari atau ke \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Upload File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Upload File}".
    \item Pengguna memasukkan \textit{file}.
    \item Pengguna menekan tombol "\textit{Upload}".
    \item Sistem menampilkan status "\textit{Success}".
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Upload}
\caption{Tabel skenario \textit{Upload File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Download File} \\ 
\hline
Deskripsi & Pengguna dapat mengunduh \textit{file} dari atau di \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Download File}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Download File}".
    \item Sistem menampilkan data.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Download}
\caption{Tabel skenario \textit{Download File}}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Melihat Kapasitas Memori Flash \\ 
\hline
Deskripsi & Membantu pengguna mengetahui sisa memori yang tersedia dalam Flash.  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Check Memori Flash}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih \textit{"Check Memori Flash"}.
    \item Sistem menampilkan keterangan mengenai kapasitas memori Flash.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Flash}
\caption{Tabel skenario Melihat Kapasitas Memori Flash}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & \textit{Restart} Node Sensor \\ 
\hline
Deskripsi & Membantu pengguna untuk \textit{restart} \textit{sensor node}  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sudah dijalankan dan pengguna memilih "\textit{Restart} Node Sensor"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna memilih "\textit{Restart} Node Sensor".
    \item Sistem menyalakan ulang \textit{sensor node}.
    \item Sistem kembali pada tampilan utama.
\end{enumerate} \\
\hline
\end{tabular}
\label{Restart}
\caption{Tabel skenario \textit{Restart} Node Sensor}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
\rowcolor{lightgray} Nama & Mematikan Aplikasi \\ 
\hline
Deskripsi & Membantu pengguna untuk mematikan program dan keluar dari aplikasi  \\ 
\hline
Aktor & Pengguna \\
\hline
Pre-kondisi & Aplikasi sedang dijalankan dan pengguna memilih "\textit{Exit}"\\
\hline
Alur Skenario & \begin{enumerate}
    \item Pengguna menjalankan aplikasi.
    \item Sistem memuat aplikasi.
    \item Sistem menampilkan pilihan untuk dipilih oleh pengguna.
    \item Pengguna menjalankan fitur yang ada.
    \item Pengguna memilih "\textit{Exit}".
    \item Sistem menyalakan \textit{sensor node}.
    \item Sistem keluar dari aplikasi dan aplikasi berhenti berjalan.
\end{enumerate} \\
\hline
\end{tabular}
\label{Exit}
\caption{Tabel skenario Mematikan Aplikasi}
\end{table}

Pada subbab ini dibuat suatu diagram kelas sederhana untuk menjelaskan kelas-kelas yang dibutuhkan dalam membangun aplikasi baca tulis \textit{file}. Aplikasi ini dibangun di PC dengan menggunakan Eclipse IDE dan menggunakan Sandbox yang sudah disediakan oleh Virtenio. Aplikasi yang dibuat terdiri dari program pada \textit{base station} dan program GUI untuk menghubungkan \textit{base station} dengan komputer pengguna.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/BS.png}
    \caption{Diagram Kelas Sederhana untuk \textit{base-station}}
    \label{fig:dkbs}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/GUI.png}
    \caption{Diagram Kelas Sederhana untuk GUI}
    \label{fig:dkgui}
\end{figure}
\newpage
Berikut adalah penjelasan dari kelas-kelas pada diagram pada Gambar \ref{fig:dkbs} dan Gambar \ref{fig:dkgui}.
\begin{itemize}
        \item Kelas BS \newline
        Kelas ini untuk menangani fungsi-fungsi yang ada pada \textit{base station}.
        \item Kelas USART \newline
        Kelas ini untuk membuat koneksi antara \textit{base station} atau \textit{sensor node} Preon32 dengan komputer pengguna.
        \item Kelas Display \newline
        Kelas ini digunakan sebagai \textit{interface} untuk pengguna seperti menampilkan komponen \textit{sensor node}.
        \item Kelas Main \newline
        Kelas ini memiliki sebuah \textit{method} untuk me-\textit{restart} \textit{sensor node}, mengirim dan mengunduh \textit{file}, melihat COM, melihat kapasitas memori, dan mematikan aplikasi.
        \item Kelas DataProcess \newline
        Kelas ini digunakan untuk mengambil data dari \textit{base station} yang akan diproses sebelum ditampilkan menjadi bentuk visual di kelas Display.
\end{itemize}

Gambar \ref{fig:flowchart} menggambarkan alur kerja aplikasi dan alur interaksi pengguna dengan aplikasi. Berikut penjelasan dari Gambar \ref{fig:flowchart}:
\begin{enumerate}
    \item Pengguna membuka aplikasi dan aplikasi berjalan.
    \item Pengguna memilih \textit{port} COM dan \textit{baudrate} yang sesuai.
    \item Pengguna dapat menginput 1 untuk menampilkan komponen \textit{sensor node}.
    \item Pengguna dapat menginput 2 untuk melakukan \textit{upload file}.
    \item Pengguna dapat menginput 3 untuk melakukan \textit{download file}.
    \item Pengguna dapat menginput 4 untuk menampikan kapasitas \textit{storage}.
    \item Pengguna dapat melakukan \textit{restart} untuk menyalakan kembali \textit{sensor node}.
\end{enumerate}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Flowchart Skripsi.png}
    \caption{Flowchart Cara Kerja Aplikasi}
    \label{fig:flowchart}
\end{figure}
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã¢â?¬Å?\textit{self synchronizing}Ã¢â?¬ï¿½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}

%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã¢â?¬Å?USB 3.1 yang sesungguhnyaÃ¢â?¬ï¿½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã¢â?¬Å?\textit{self synchronizing}Ã¢â?¬ï¿½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}





%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}
Pada bab ini dijelaskan dasar-dasar teori mengenai \textit{Wireless Sensor Network} (WSN), \textit{sensor node}, Preon32, USB, UART dan USART.


\section{\textit{Wireless Sensor Network}}
\textit{Wireless Sensor Network} (WSN) merupakan sebuah jaringan \textit{wireless} dari sekumpulan \textit{sensor node} yang tersebar pada suatu tempat, memiliki kemampuan untuk mengukur kondisi lingkungan disekitarnya (\textit{sensing}), berinteraksi dengan \textit{sensor node} lainnya, serta melakukan komputasi data tersebut dan memiliki \textit{storage capabilities}. \textit{Sensor node} berkomunikasi tidak hanya dengan satu sama lain tetapi juga dengan \textit{base station} dengan menggunakan radio nirkabel dan hal ini memungkinkan untuk menyebarkan data sensor tersebut ke pemrosesan jarak jauh, visualisasi, analisis, dan sistem penyimpanan \cite{book}. Berikut Gambar merupakan arsitektur dari {Wireless Sensor Network} (WSN).
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Gambars WSN.png}
    \caption{Arsitektur \textit{Wireless Sensor Network} (WSN)}
    \label{fig:WSN}
\end{figure}

\subsection{Penerapan \textit{Wireless Sensor Network} \cite{handbook}}
\textit{Wireless Sensor Network} (WSN) ini digunakan untuk keperluan militer yang berfungsi untuk mendeteksi serangan atau keberadaan musuh di daratan maupun di lautan. Sesuai perkembangan zaman, \textit{sensor node} ini mulai dikembangkan untuk membantu berbagai bidang kehidupan manusia. Berikut merupakan beberapa contoh dari penerapan \textit{Wireless Sensor Network} (WSN):
\begin{enumerate}
\item Bidang Militer \newline
Pada bidang militer ini \textit{Wireless Sensor Network} (WSN) digunakan untuk melakukan pengiriman pesan, pengendalian, sarana komunikasi, dan untuk mendeteksi serangan dari musuh.
\item Bidang Transportasi \newline
Pada bidang transportasi ini \textit{Wireless Sensor Network} (WSN) digunakan untuk mendeteksi arus lalu lintas secara aktual.
\item Bidang Pertanian \newline
Pada bidang pertanian ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para petani untuk mengelola dan memantau penggunaan air dalam proses irigasi dan mengelola pembuangan pertanian mereka.
\item Bidang Kesehatan\newline
Pada bidang kesehatan ini \textit{Wireless Sensor Network} (WSN) digunakan untuk membantu para penyandang disabilitas, diagnosis penyakit, \textit{monitoring} pasien, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.
\item Deteksi Lingkungan\newline
\textit{Wireless Sensor Network} (WSN) ini dapat mendeteksi suatu lingkungan seperti mendeteksi gunung berapi, polusi udara, kebakaran hutan, gempa bumi, dan longsor.
\end{enumerate}

\subsection{Karakteristik WSN \cite{Open}}
WSN sudah digunakan untuk untuk kebutuhan di dunia nyata namun masih tanpa pengawasan \textit{environment} untuk mengukur berbagai parameter. Berikut merupakan karakteristik penting dari WSN yaitu:
    \subsubsection{\textit{Low Cost}}
    Pada WSN biasanya menggunakan ratusan atau ribuan \textit{sensor node} untuk mengukur kondisi lingkungan, karena itu biaya \textit{sensor node} harus dijaga serendah mungkin.
    
    \subsubsection{\textit{Energy Efficient}} 
    Pada WSN energi digunakan untuk tujuan yang berbeda seperti untuk komputasi, komunikasi, dan penyimpanan. Pada saat melakukan komunikasi, \textit{sensor node} menghabiskan banyak energi. Jika kehabisan daya energi maka \textit{sensor node} tersebut menjadi tidak valid karena tidak ada opsi untuk mengisi ulang energi, sehingga diperlukan sebuah protokol dan algoritma untuk mempertimbangkan konsumsi energi di dalam WSN.
    
    \subsubsection{\textit{Computational Power}} 
    Biasanya node memiliki kemampuan komputasi yang terbatas sehingga biaya dan energi perlu dipertimbangkan.
    
    \subsubsection{\textit{Communication Capabilities}}
    WSN biasanya berkomunikasi menggunakan gelombang radio melalui saluran nirkabel yang memiliki properti berkomunikasi dalam jarak pendek, dengan bandwidth yang sempit dan dinamis. Saluran komunikasi dapat berupa dua arah atau searah. Dengan lingkungan operasional yang tidak dijaga dan tidak bersahabat, sulit untuk menjalankan WSN dengan lancar. Jadi, perangkat keras dan perangkat lunak untuk berkomunikasi harus mempertimbangkan ketahanan, keamanan, dan ketahanan.
    
    \subsubsection{\textit{Security and Privacy}} 
    Setiap \textit{sensor node} harus memiliki mekanisme keamanan yang memadai untuk mencegah akses yang tidak sah, serangan, dan kerusakan informasi yang tidak disengaja maupun yang disengaja di dalam \textit{sensor node}.
   
    \subsubsection{\textit{Distributed Sensing and Processing}}
    Sejumlah besar \textit{sensor node} didistribusikan secara seragam atau acak. Setiap node WSN mampu mengumpulkan, menyortir, memproses, menggabungkan, dan mengirim data ke \textit{sink}. Oleh karena itu, penginderaan terdistribusi memberikan ketahanan sistem.
    
    \subsubsection{\textit{Dynamic Network Topology}}
    Secara umum WSN adalah sebuah jaringan dinamis. \textit{sensor node} dapat gagal karena kehabisan baterai atau keadaan lain, saluran komunikasi dapat terganggu serta \textit{sensor node} tambahan dapat ditambahkan ke jaringan yang mengakibatkan seringnya perubahan dalam topologi jaringan. Dengan demikian, node WSN harus tertanam dengan fungsi konfigurasi ulang dan penyesuaian diri.
    
    \subsubsection{\textit{Self-Organization}}
    Sebuah \textit{sensor node} di dalam jaringan harus memiliki kemampuan untuk mengatur diri mereka sendiri saat \textit{sensor node} disebarkan dengan cara yang tidak diketahui di lingkungan yang tidak dijaga dan bermusuhan. \textit{sensor node} bekerja sama untuk menyesuaikan diri dengan algoritma yang terdistribusi dan membentuk jaringan secara otomatis.
    
    \subsubsection{\textit{Multi-Hop Communication}}
    Sejumlah besar \textit{sensor node} digunakan di WSN. Jadi, cara yang layak untuk berkomunikasi dengan \textit{sinker} atau \textit{base station} adalah dengan cara mengambil bantuan node perantara melalui jalur \textit{routing}. Jika seseorang perlu berkomunikasi dengan node atau \textit{base station} lain yang berada di luar frekuensi radionya, maka harus melalui rute \textit{multi-hop} oleh node perantara.
    
    \subsubsection{\textit{Application Oriented}}
    WSN berbeda dari jaringan konvensional karena sifatnya. Hal ini sangat tergantung pada rentang aplikasi dari militer, lingkungan serta sektor kesehatan. Node disebarkan secara acak dan direntangkan tergantung pada jenis penggunaan.
    
    \subsubsection{\textit{Robust Operations}}
    Karena sensor akan disebarkan di lingkungan yang besar dan terkadang tidak bersahabat. Jadi, \textit{sensor node} harus salah dan toleran terhadap kesalahan. Oleh karena itu, \textit{sensor node} harus memiliki kemampuan seperti \textit{self-test}, \textit{self-calibrate}, dan \textit{self-repair}.
    
    \subsubsection{\textit{Small Physical Size}}
    \textit{Sensor node} umumnya berukuran kecil dengan kisaran terbatas. Karena ukurannya yang terbatas, energinya yang terbatas membuat kemampuan komunikasi menjadi rendah.
    
    \subsection{Topologi WSN \cite{topololgi}}
    Pada jaringan WSN biasanya menggunakan sebuah topologi yang berfungsi untuk meyakinkan semua jaringan yang dibangun dapat saling berkomunikasi atau sudah sesuai dengan tujuannya. Topologi yang biasa digunakan oleh WSN adalah \textit{star}, \textit{mesh} atau, \textit{tree}, namun masih banyak contoh topologi lain seperti topologi \textit{point-to-point}, \textit{ring}, \textit{linear}, dan \textit{bus}.
    
    \subsubsection{Topologi \textit{Point-to-Point}}
    Topologi \textit{point-to-point} menghubungkan dua titik akhir seperti pada Gambar \ref{fig:point}. Topologi ini bisa permanen atau \textit{switched}. Topologi \textit{point-to-point} permanen adalah koneksi yang tertanam antara dua titik. Topologi \textit{switched point-top-point} adalah koneksi yang dapat dipindahkan di antara node akhir yang berbeda.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Pointtopoints.jpg}
    \caption{Topologi \textit{Point-to-Point}}
    \label{fig:point}
    \end{figure}
    
    \subsubsection{Topologi \textit{Bus}}
    Topologi \textit{bus} adalah konfigurasi di mana setiap node terhubung ke komunikasi \textit{bus} bersama, seperti yang ditunjukkan pada Gambar \ref{fig:buss}. Sebuah sinyal ditransmisikan kedua arah di sepanjang \textit{bus} hingga mencapai tujuan yang dituju. Jaringan \textit{bus} harus menyertakan sistem penghindaran tabrakan untuk menyelesaikan masalah ketika dua node secara bersamaan mengirimkan data di \textit{bus}. Jaringan \textit{bus} ini sederhana dan mudah dipasang. Namun, ada satu titik kegagalan atau jika \textit{bus} gagal, seluruh jaringan akan gagal.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Buss.jpg}
    \caption{Topologi \textit{Bus}}
    \label{fig:buss}
    \end{figure}
    
    \subsubsection{Topologi \textit{Linear}}
    Topologi \textit{linear} adalah hubungan dua arah antara satu node dan node berikutnya, seperti yang ditunjukkan pada Gambar \ref{fig:Linear}. Ada dua node penghentian di ujung jaringan yang memiliki satu koneksi ke node terdekat, dan semua node lainnya terhubung ke dua node lainnya. Di dalam topologi \textit{Linear} ini, node saling bergantung satu sama lain untuk menyebarkan pesan ke node berikutnya. Jika sebuah node gagal, setiap node yang terhubung ke node tersebut terputus dari jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Linears.jpg}
    \caption{Topologi \textit{Linear}}
    \label{fig:Linear}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Ring}}
    Topologi \textit{ring} adalah jaringan yang diatur secara melingkar, seperti yang ditunjukkan pada Gambar \ref{fig:Ring}. Topologi ini mirip dengan topologi linier, di mana simpul akhir terhubung satu sama lain. Dalam konfigurasi ini, setiap node terhubung ke tepat dua node lain dan data mengalir dalam satu arah dari sumber ke setiap node hingga menemukan penerima yang dituju. Topologi ini mudah dipasang dan dikonfigurasi ulang. Namun, biaya pengelolaannya mahal karena jaringan ring dapat terganggu oleh kegagalan satu node. Banyak jaringan menambahkan ring komunikasi kedua yang dapat mengirimkan data ke arah yang berlawanan untuk mengatasi masalah ini. Topologi ini adalah cara umum untuk menghubungkan kantor kecil dan sekolah, tetapi jarang digunakan lagi.
     
     \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Rings.jpg}
    \caption{Topologi \textit{Ring}}
    \label{fig:Ring}
    \end{figure}
    
    \subsubsection{Topologi \textit{Star}}
    Topologi \textit{star} adalah salah satu topologi jaringan sensor yang paling umum. Topologi \textit{star} terdiri dari satu "simpul pusat", seperti \textit{hub} atau \textit{switch} yang dihubungkan ke setiap simpul dalam jaringan, seperti yang ditunjukkan pada Gambar \ref{fig:Star}. Topologi ini mudah dirancang, diterapkan, dan diperluas. Semua lalu lintas data mengalir melalui node pusat. Oleh karena itu, diperlukan simpul pusat yang cerdas. Kegagalan node ini akan mengakibatkan kegagalan seluruh jaringan.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Stars.jpg}
    \caption{Topologi \textit{Star}}
    \label{fig:Star}
    \end{figure}
    \newpage
    \subsubsection{Topologi \textit{Tree}}
    Topologi \textit{tree} adalah node hierarki di mana tingkat tertinggi dari hierarki adalah satu \textit{root node}, dan node ini terhubung ke satu atau banyak simpul pada tingkat di bawahnya, seperti yang ditunjukkan pada Gambar \ref{fig:Tree}. Topologi \textit{tree} dapat berisi banyak tingkatan node. Pemrosesan dan daya dalam node meningkat saat data bergerak dari cabang pohon menuju \textit{root node}, hal ini memungkinkan data untuk diproses di dekat tempat data dihasilkan. Topologi ini dapat diskalakan dan strukturnya yang sederhana memudahkan untuk mengidentifikasi dan mengisolasi kesalahan. Jaringan \textit{tree} akan menjadi semakin sulit untuk dikelola jika mereka semakin besar.
    
    \begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{Gambar/Trees.jpg}
    \caption{Topologi \textit{Tree}}
    \label{fig:Tree}
    \end{figure}
    
    \subsubsection{Topologi \textit{Mesh}}
    Node topologi \textit{mesh} menyebarkan datanya sendiri dan juga bertindak sebagai \textit{relay} untuk menyebarkan data dari node lain. Ada dua bentuk topologi \textit{mesh} yaitu \textit{partially connected mesh}, dimana beberapa node terhubung ke lebih dari satu node lainnya, ditunjukkan pada Gambar \ref{fig:Mesh} dan \textit{fully connected mesh}, di mana setiap node terhubung ke setiap node lain di \textit{mesh}, seperti ditunjukkan pada Gambar \ref{fig:Full}. Jaringan \textit{mesh} menyembuhkan diri sendiri, karena data dapat dirutekan di sepanjang jalur yang berbeda jika node gagal. Jaringan \textit{fully connected mesh} ini tidak cocok untuk jaringan sensor besar karena jumlah koneksi yang diperlukan menjadi tidak dapat dikelola. Jaringan \textit{partially connected mesh} memberikan kemampuan pemulihan sendiri dari jaringan yang terhubung sepenuhnya tanpa \textit{overhead} koneksi. Topologi \textit{mesh} paling sering ditemukan di jaringan nirkabel.
    
    \begin{figure}[!htb]
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/mesh.jpeg}
    \caption{Topologi \textit{Mesh}}
    \label{fig:Mesh}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=.7\linewidth]{Gambar/full.jpeg}
    \caption{\textit{Fully connected mesh}}
    \label{fig:Full}
     \end{minipage}
    \end{figure}

    
    \subsection{Sistem Operasi}
    Setiap \textit{sensor node} memerlukan sistem operasi untuk mengontrol aktivitas-aktivitasnya dan memastikan agar perangkatnya dapat bekerja dan dimanfaatkan secara optimal. Sistem operasi berfungsi untuk menyediakan sebuah fungsi-fungsi dasar untuk mengatur cara kerja dari perangkat keras dan perangkat lunak, termasuk menyediakan \textit{interface} pemrograman untuk pengembangan aplikasi WSN. Berikut merupakan beberapa contoh sistem operasi WSN yaitu:
    \begin{itemize}
        \item TinyOS
        \item Contiki
        \item Nano-RK
        \item LiteOS
        \item RTOS
        \item PreonVM
    \end{itemize}
    
    \subsection{Protokol \textit{Stack} pada WSN \cite{Open}} 
    Arsitektur komunikasi WSN sedikit berbeda dari komunikasi komputer konvensional dan jaringan komputer. Arsitektur komunikasi dapat diklasifikasikan dalam berbagai lapisan. Untuk mendapatkan efisiensi maksimum dengan sumber daya terbatas dan \textit{overhead} rendah, WSN tidak terlalu menganut arsitektur berlapis model OSI dari jaringan konvensional.
    
    Namun demikian, model \textit{layered} ini berguna di WSN untuk mengkategorikan protokol, serangan dan pertahanan. Jadi, berbeda dengan tujuh lapisan tradisional, WSN direduksi menjadi lima lapisan \cite{IEEE} yang meliputi \textit{physical layer, data link layer, network layer, transport layer,} dan \textit{application layer}. Keuntungan dari model \textit{layered} ini adalah fungsi yang secara konseptual serupa dapat digabungkan pada satu lapisan. Gambar \ref{fig:protokol}  menunjukkan model protokol komunikasi jaringan sensor nirkabel.
    \begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{Gambar/Protokol WSN.jpg}
    \caption{Protokol \textit{Stack} WSN}
    \label{fig:protokol}
    \end{figure}
    \newpage
    \textit{Physical layer} membahas detail perangkat keras dari mekanisme komunikasi nirkabel. Lapisan ini bertanggung jawab untuk pemilihan frekuensi, pembangkitan frekuensi pembawa, deteksi sinyal, modulasi, dan enkripsi data. \textit{Data link layer} berkaitan dengan protokol kontrol akses media (MAC). Karena saluran nirkabel rentan terhadap kebisingan dan \textit{sensor node} dapat mengubah lokasi, protokol MAC pada \textit{data link layer} harus waspada terhadap daya dan harus memiliki kemampuan meminimalkan tabrakan. \cite{1203451} \textit{Network layer} mengelola perutean data yang disediakan oleh \textit{transport layer} atau antar node. \textit{Transport layer} bertanggung jawab untuk menjaga aliran data agar tetap \textit{reliable} jika aplikasi WSN membutuhkannya. Sedangkan \textit{application layer} meliputi berbagai macam protokol yang ada pada \textit{layer} ini untuk menjalankan berbagai aplikasi tergantung dari penginderaan lingkungan fisik.
    

\section{\textit{Sensor Node}}
\textit{Sensor node} merupakan sebuah sebuah node yang dilengkapi oleh satu atau beberapa perangkat sensor yang berfungsi untuk membaca data lingkungan atau objek yang ingin dipantau. \textit{sensor node} mampu mendapatkan informasi tentang kondisi lingkungan atau objek dan langsung memanipulasi data tersebut dengan cara melakukan perhitungan maupun dengan cara mengirimkan data tersebut ke \textit{sensor node} lainnya. Berikut merupakan beberapa contoh \textit{sensor node} antara lain yaitu Lotus, Mica, iMote, Preon32, dan Preon32 Shuttle.

\subsection{Struktur \textit{Sensor Node}}
Setiap \textit{sensor node} memiliki kemampuan \textit{sensing}, komputasi data dan komunikasi. Semua komponen yang ada di \textit{sensor node} akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi data dan komunikasi, dan menjaga penggunaan energi seminimal mungkin untuk menghemat daya.

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Struktur Sensor Node.png}
    \caption{Struktur \textit{sensor node}}
    \label{fig:sensor node}
\end{figure}
\newpage
Pada umumnya sesuai pada Gambar \ref{fig:sensor node} , sebuah \textit{sensor node} terbagi menjadi 4 komponen utama \cite{wsn} yaitu:
\subsubsection{1. \textit{Power Unit}}
    \textit{Power unit} merupakan sebuah komponen yang menyediakan sumber daya bagi komponen-komponen lainnya pada \textit{sensor node} agar dapat beroperasi. Sumber daya komponen ini dapat berasal dari 2 cara yaitu \textit{energy stroring} dan \textit{energy harvesting}. \textit{Energy stroring} adalah penggunaan baterai dari sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy harvesting} adalah penggunaan pada saat membuat suatu \textit{Wireless Sensor Network} (WSN) yang akan digunakan dalam waktu yang lama dan membutuhkan energi yang tidak terbatas. Cara melakukan \textit{energy harvesting} adalah dengan cara pemanfaatan cahaya matahari, angin dan air untuk menggerakan kincir yang akan menghasilkan listrik sehingga dapat menghasilkan sumber energi untuk \textit{sensor node}.
    
\subsubsection{2. \textit{Sensing Unit}}
    \textit{Sensing unit} merupakan sebuah komponen yang untuk melakukan \textit{sensing} terhadap lingkungan. Komponen ini biasanya terdiri dari satu atau beberapa sensor dan sebuah \textit{Analog-to-Digital Converter} (ADC), yang merupakan sebuah alat untuk mengubah sinyal analog menjadi sinyal digital. Sensor ini dibagi menjadi 3 kategori bagian yaitu:
    \begin{enumerate}
        \item \textit{Passive, Omnidirectional Sensors}. \newline
        Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat \textit{sensor node} tersebut tanpa mengubah lingkungannya. Sensor ini memiliki sifat \textit{self-powered} yang berartikan bahwa sensor ini mendapatkan energi yang mereka butuhkan dari lingkungannya dan sifat \textit{Omnidirectional} yang berartikan bahwa sensor ini tidak memiliki arah. Contoh sensor ini adalah sensor getaran, sensor cahaya, mikrofon, sensor kelembaban, sensor tekanan udara, sensor deteksi asap, dan termometer.
        
        \item \textit{Passive, Narrow-Beam Sensors}. \newline
        Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu sama-sama tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki daerah pengukuran atau arah. Contoh dari sensor ini adalah kamera.
        
        \item \textit{Active Sensor}. \newline
        Sensor ini aktif dalam memeriksa lingkungannya. Sensor ini menghasilkan sebuah gelombang untuk melakukan deteksi. Contoh sensor ini adalah sonar dan radar.
    \end{enumerate}
    Sinyal digital ini berisikan sebuah data informasi lingkungan yang sedang dipantau dan akan dikirimkan pada \textit{processing unit}. 
    
  \subsubsection{3.\textit{Processing Unit}} 
    \textit{Processing unit} merupakan sebuah komponen inti dari \textit{sensor node} yang terdiri dari mikrokontroler dengan memori sehingga \textit{sensor node} dapat menyimpan dan memanipulasi data yang diterimanya. Data yang telah diolah ini kemudian dikirimkan ke \textit{sensor node} lainnya dengan perangkat komunikasi yang dimilikinya. Mikrokontroler ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian \textit{controller} saja yang aktif.
    
    \subsubsection{4. \textit{Communication Unit}} 
    \textit{Communication Unit} merupakan sebuah komponen yang mengandung radio jangka pendek yang berfungsi untuk melakukan transmisi dan menerima data melalui saluran radio. Pada \textit{sensor node} dibutuhkan sebuah \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat disebut sebagai \textit{transceiver} yang bertugas untuk mengubah aliran \textit{bit} menjadi gelombang radio dan sebaliknya.


\section{Preon32}
Preon32 adalah salah satu dari jenis \textit{sensor node} yang disediakan oleh Virtenio\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}}. Preon32 ini menggunakan PreonVM sabagai \textit{operating software}. Pada umumnya Preon32 ini memiliki 5 jenis sensor standar\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}} pada sebuah \textit{board}. Sensor yang ada pada Preon32 ini antara lain sensor suhu (\textit{temperature sensor}), sensor kelembaban udara (\textit{relative humidity sensor}), sensor intensitas cahaya (\textit{light intensity sensor}), sensor getaran (\textit{acceleration sensor}), sensor tekanan udara (\textit{air pressure sensor}). Namun pada versi tambahan Preon32 terdapat beberapa tambahan sensor untuk mendeteksi medan magnet, dan \textit{gyroscope} untuk melengkapi 5 sensor yang sudah ada sebelumnya. Semua jenis tersebut dapat diatur melalui PreonVM dan pemrogramannya dapat dilakukan dengan bahasa pemrograman Java. Pada Gambar \ref{fig:board} ditunjukkan sebuah \textit{board} Preon32 beserta dengan posisi sensor-sensor tersebut diletakkan pada sebuah \textit{board} Preon32.

\begin{figure}[htp]
    \centering
    \includegraphics[width=17cm]{Gambar/board.jpg}
    \caption{Preon32 board}
    \label{fig:board}
\end{figure}
Preon32 ini dapat diaplikasikan untuk berbagai hal seperti:
    \begin{enumerate}
        \item \textit{Home Automation} untuk mengintegrasikan berbagai sistem pada rumah, navigasi dan monitoring area.
        \item Aplikasi pada jaringan nirkabel.
        \item Platform untuk membantu penelitian.
        \item Algoritma sensor data \textit{fushion}.
    \end{enumerate}
\newpage
\subsection{Komponen pada Preon32}
Berikut adalah spesifikasi setiap komponen yang dimiliki oleh Preon32 \footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32/}} yaitu:
\subsubsection{\textit{Microcontroller}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{9cm}} 
\textbullet & Processor core & : & 32-Bit-RISC \\
\textbullet & Clock frequency & : & up to 72MHz \\
\textbullet & RAM & : & 64 kByte SRAM \\
\textbullet & ROM & : & 256 kByte Flash \\
\textbullet & Current consumption & : & 3,7 mA (active, 8MHz),\\ 
 & (typ.)& & 28,3 mA(active, 72Mhz), 26 uA (Stop-Mode), \\
 & & & 1,3 mA (Sleep state, without peripherals) \\
\end{tabular}
\end{table}

\subsubsection{\textit{Radio Transceiver}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Frequency band} & : & 2400.0 - 2483.5 \textit{MHz} \\
\textbullet & \textit{Channels} & : & 16 \\
\textbullet & \textit{Channel spacing} & : & 5 \\
\textbullet & \textit{Data rate} & : & 250 \textit{kBit/s},\\ 
&&& 512 \textit{kBit/s},\\ 
& & & 1 M\textit{Bit/s},\\
&&& 2 \textit{MBit/s}\\
\textbullet & \textit{Transmitting power} & : & -17 \textit{dBm} bis +3 \textit{dBm}\\
\textbullet & \textit{Range} & : & \textit{up to} 150 \textit{m in free field},\\ 
& & & \textit{up to} 30 \textit{m in buildings}\\
\textbullet & \textit{Current consumption} & : & 20 \textit{nA} (\textit{sleep state}), \\
& (\textit{typ.})& & 12,3 \textit{mA(receive mode)}, \\
& & & 14,0 \textit{mA (transmit mode)}\\
\end{tabular}
\end{table}

\subsubsection{\textit{Interfaces}}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Processor core} & : & 32-\textit{Bit}-RISC \\
\textbullet & \textit{Clock frequency} & : & \textit{up to} 72\textit{MHz} \\
\textbullet & RAM & : & 64 \textit{kByte} SRAM \\
\textbullet & ROM & : & 256 \textit{kByte} Flash \\
\textbullet & \textit{Current consumption} & : & 3,7 \textit{mA} (\textit{active}, 8\textit{MHz}),\\ 
& (\textit{typ.})& & 28,3 \textit{mA}(\textit{active}, 72\textit{Mhz}), 26 \textit{uA} (\textit{Stop-Mode}), \\
&&& 1,3 \textit{mA} (\textit{Sleep state, without peripherals}) \\
\end{tabular}
\end{table}

\subsubsection{Serial Flash}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{3.5cm} c p{6cm}} 
\textbullet & \textit{Size} & : & 8 \textit{MBit} (\textit{also} 16 \textit{MBit available}) \\
\textbullet & \textit{Technology} & : & Serial Flash \\
\textbullet & \textit{Access} & : & \textit{up to} 86 \textit{MHz clock frequency on} SPI \\
\end{tabular}
\end{table}
\newpage
\subsection{Spesifikasi Sensor pada Preon32}
Berikut adalah spesifikasi setiap sensor standar yang dimiliki oleh Preon32 yaitu\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle-varisen/}}: 

\subsubsection{Sensor Suhu (\textit{Temperature Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADT7410 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-\textit{Bit} \\
\textbullet & \textit{Range} & : & -40$^{\circ}$C \textit{up to} +105$^{\circ}$C \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Tekanan Udara (\textit{Air Pressure Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Freescale} \\
\textbullet & \textit{Model} & : & MPL115A2 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 0,15 \textit{kPa} \\
\textbullet & \textit{Range} & : & 10 \textit{kPa} \textit{up to} 115 \textit{kPa} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 1.0 \textit{kPa} \\
\end{tabular}
\end{table}

\subsubsection{Sensor Kelembaban Udara Relatif (\textit{Relative Humidity Sensor})}
\vspace{-0.5cm}
\begin{table}[H] 
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Sensirion \\
\textbullet & \textit{Model} & : & SHT21 \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 12-\textit{Bit} \\
\textbullet & \textit{Range} & : & 0\% RH \textit{up to} 100\% RH \textit{(typ.)} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 0.5$^{\circ}$C \\
\end{tabular}
\end{table}

\subsubsection{Sensor Getaran (\textit{Acceleration Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & \textit{Analog Devices} \\
\textbullet & \textit{Model} & : & ADXL345 \\
\textbullet & \textit{Interface} & : & \textit{digital}, SPI \\
 \textbullet & \textit{Resolution} & : & 13-\textit{Bit per axis} \\
\textbullet & \textit{Range} & : & $\pm$ g, 3 \textit{axis} \\
\textbullet & \textit{Accuracy} & : & $\pm$ 3,9 \textit{mg}/LSB \\
\end{tabular}
\end{table}

\subsubsection{Sensor Intensitas Cahaya (\textit{Light Intensity Sensor})}
\vspace{-0.5cm}
\begin{table}[H]
\begin{tabular}{ c p{2cm} c p{5cm}} 
\textbullet & \textit{Manufacture} & : & Rohm \\
\textbullet & \textit{Model} & : & BH1715FVC \\
\textbullet & \textit{Interface} & : & \textit{digital}, I2C \\
\textbullet & \textit{Resolution} & : & 16-Bit \\
\textbullet & \textit{Range} & : & 1 \textit{lx up to} 65355 \textit{lx} \\
\end{tabular}
\end{table}

\newpage
\subsection{Preon32 Shuttle}
Preon32 Shuttle merupakan Preon32 yang sudah diperbaharui dan dilengkapi dengan beberapa modul - modul tambahan\footnote{\url{https://www.virtenio.com/en/portfolio-items/preon32-shuttle/}}. Sensor Preon32 Shuttle ini memiliki energi yang sangat terbatas, sehingga perlu dilakukan operasi yang sangat efisien untuk menghemat energi dari Preon32 Shuttle agar tidak mudah habis. Bentuk dari sensor Preon32 Shuttle ini dapat dilihat pada Gambar \ref{fig:Preon32Shuttle}. Beberapa modul tambahan yang dimiliki oleh sensor Preon32 Shuttle ini adalah sebagai berikut:
\begin{itemize}
    \item Memiliki koneksi dengan USB.
    \item Dapat menerima sumber daya atau energi dari baterai.
    \item Memiliki tombol-tombol yang dapat digunakan oleh pengguna.
\end{itemize}
\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/Preon32Shuttle.jpg}
    \caption{Preon32 Shuttle}
    \label{fig:Preon32Shuttle}
\end{figure}

\subsection{Pemrograman Preon32}
Pada subbab ini akan dijelaskan bagaimana cara pemrograman pada Preon32 termasuk struktur \textit{file} dan perintah-perintah yang digunakan pada ANT Scripts. Pemrograman Preon32 dilakukan dengan menggunakan Java beserta \textit{tools} yaitu Java Development Kit (JDK) versi 8. Untuk lingkungan pemrograman Java menggunakan Eclipse dan untuk proses \textit{compile} dan menjalankan program Preon32 menggunakan ANT \textit{Scripts} dan \textit{Sandbox} Preon32 yang disediakan oleh Virtenio yang berisi \textit{file} dan \textit{folder} yang mengatur struktur program serta untuk menyimpan kelas dan \textit{library} yang akan digunakan.

\subsubsection{\textit{Sandbox} Preon32}
Berikut merupakan susunan \textit{file} dan folder pada Sandbox Preon32 yang disediakan oleh Virtenio:
\begin{enumerate}
    \item bin
    \item build
    \item config
    \item example
    \item lib
    \item license
    \item src
    \item target
    \item .classpath
    \item .project
    \item build.xml
    \item buildUser.xml
\end{enumerate}

\subsubsection{ANT \textit{Scripts}}
Tabel \ref{fungsi ANT} merupakan fungsi-fungsi yang terdapat pada ANT Scripts yang digunakan untuk melakukan \textit{compile} pada Preon32:
\begin{table}[H]
\centering
\begin{tabular}{ |p{5cm}|p{5cm}| } 
\hline
\rowcolor{lightgray} Nama Fungsi & Nama Fungsi \\ 
\hline
.all & cmd.license.upload  \\ 
\hline
.run & cmd.module.run \\
\hline
boot.erase & cmd.module.upload  \\ 
\hline
boot.firmware.upload & cmd.module.upload.run  \\ 
\hline
boot.info & cmd.module.list  \\ 
\hline
boot.options.cmd.disable & cmd.properties.all  \\ 
\hline
boot.options.cmd.enable & cmd.properties.clear  \\ 
\hline
boot.options.modify.disable & cmd.properties.list  \\ 
\hline
boot.options.modify.enable & cmd.properties.upload  \\ 
\hline
boot.options.print & cmd.terminal.open  \\ 
\hline
boot.options.read.protect & cmd.time.synchronize  \\ 
\hline
boot.options.read.unprotect & devel.all  \\ 
\hline
boot.options.reset & devel.clean  \\ 
\hline
boot.options.wdg.disable & devel.compile  \\ 
\hline
boot.options.wdg.enable & devel.jar  \\ 
\hline
boot.options.write.protect & devel.proguard  \\ 
\hline
boot.options.write.unprotect & devel.properties  \\ 
\hline
boot.reset & devel.vmm  \\ 
\hline
cmd.info & init  \\ 
\hline
\end{tabular}
\label{fungsi ANT}
\caption{Tabel Fungsi-fungsi pada ANT \textit{Scripts}}
\end{table}

\begin{lstlisting}
    <target name="context.set.1">
        <switchContext to="config/context1.properties" />
    </target>
\end{lstlisting}
Selain fungsi-fungsi pada tabel \ref{fungsi ANT}, terdapat sebuah \textit{file} penting yang menjadi sebuah pengatur jalannya sebuah program pada Preon32, yaitu Context.properties pada folder config, berikut merupakan beberapa properti penting dalam folder ini yaitu:
\begin{itemize}
    \item mainClass.name : Merupakan nama kelas utama yang akan digunakan dan dieksekusi.
    \item module.name : Merupakan nama dari sebuah modul yang telah dibuat. Modul yang dibuat dapat berjalan secara automatis dengan menggunakan nama "\textit{autostart}" pada module.name ini.
    \item target.dir : Merupakan direktori yang berisi \textit{firmware} sesuai dengan perangkat yang digunakan yaitu Preon32.
    \item device.properties.file : Merupakan sebuah \textit{properties} yang didefinisikan pada file ini dapat dibaca dalam aplikasi pengguna.
    \item comport : Menujukkan sebuah \textit{port} yang terhubung antara komputer dengan Preon32.
\end{itemize}
\subsection{PreonVM}
\label{PreonVM} 
PreonVM adalah mesin virtual (VM) dari Virtenio untuk digunakan dalam sistem tertanam dengan sumber daya yang sangat rendah seperti modul radio Preon32 dari Virtenio \footnote{\url{https://www.virtenio.com/en/portfolio-items/preonvm/}}. Mesin virtual ini sangat dioptimalkan, tidak memerlukan sistem operasi tambahan, dan berjalan langsung di mikrokontroler. Pendekatan ini memungkinkan kita untuk menggunakan aplikasi di Java melalui proses transformasi untuk modul radio Preon32. 

Dalam konteks ini, Virtenio menawarkan pustaka perangkat lunak yang sesuai untuk berbagai antarmuka. Hal ini membuat pemrograman aplikasi yang merekam data sensor dan kontrol aktuator menjadi mungkin. Selain itu, antarmuka radio untuk IEEE802.15.4 dan enkripsi AES di perangkat keras disebutkan sebagai komponen inovatif yang mudah digunakan dalam mesin virtual.
\subsubsection{Karakteristik PreonVM}
PreonVM memiliki banyak karakteristik antara lain yaitu:
\begin{enumerate}
    \item Berjalan pada mikrokontroler 8-\textit{bit} atau 32-\textit{bit}.
    \item Membutuhkan ROM / Flash kurang dari 64 \textit{KByte}.
    \item Tidak diperlukan sistem operasi tambahan (Pendekatan \textit{bare metal}).
    \item Mendukung metode \textit{fast native}. 
    \item Mendukung konsep \textit{asynchronous} dan \textit{synchronous}
    \item Mendukung semua tipe data Java seperti \textit{char, byte, int, long, float} atau \textit{double}.
    \item Operasi aritmatika hingga 64-Bit (\textit{long, double}).
    \item Mendukung \textit{thread} dan pernyataan yang tersinkronisasi.
    \item Pengumpulan sampah dengan difragmentasi memori.
    \item Mendukung penanganan \textit{exception}.
    \item Properti sistem untuk konfigurasi aplikasi.
    \item Mengkompilasi kelas-kelas JavaTM menjadi modul sistem dengan ukuran kecil ukuran program.
    \item Mudah dibawa ke \textit{platform} lain dengan perangkat keras minimal ketergantungan.
    \item Mendukung model \textit{stack} yang berbeda tergantung pada yang digunakan sistem.
\end{enumerate}

\subsubsection{Kelebihan PreonVM}
Berikut merupakan kelebihan yang dihadirkan oleh Virtenio yaitu:
\begin{enumerate}
    \item Kenyamanan.
    \item Kompleksitas bahasa.
    \item Keamanan mesin virtual yang digabungkan dengan bahasa pemrograman berorientasi objek ke dalam dunia sistem tertanam.
    \item Menawarkan mesin virtual sebagai perangkat lunak operasi inovatif untuk modul radio Preon32 yang menggunakan jaringan nirkabel sesuai dengan IEEE802.15.4.
    \item Membantu untuk memisahkan proses pengembangan perangkat keras dan aplikasi piranti lunak.
    \item Mengoptimalkan untuk menjalankan aplikasi pada mikrokontroler 8-\textit{bit} atau 32-bit kecil dengan RAM 8 \textit{Kbytes} dan Flash 128 \textit{Kbytes}.
    \item Aplikasi menjadi independen dari arsitektur yang digunakan. Dengan demikian, aplikasi berjalan tanpa modifikasi dan tanpa modifikasi manual pada \textit{platform} perangkat keras yang berbeda seperti pada Gambar \ref{fig:kelebihan}.
\end{enumerate}

\begin{figure}[htp]
    \centering
    \includegraphics[width=15cm]{Gambar/KelebihanPreonVM.jpg}
    \caption{Kelebihan penggunaan mesin virtual di \textit{platform} yang berbeda}
    \label{fig:kelebihan}
\end{figure}

    \textit{Virtual machine} juga membantu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah.

\subsection{Virtenio VM Java \textit{Class Library}}
Preon32 menggunakan PreonVM sebagai \textit{virtual machine} dan menggunakan Java sebagai aplikasi untuk melakukan proses transformasi untuk modul radio Preon32. \textit{Class library} yang disediakan oleh Virtenio ini dibagi menjadi beberapa \textit{package} yang dapat dilihat pada \textit{website} resmi dari Virtenio\footnote{\url{https://www.virtenio.com/assets/vm/javadoc/overview-summary.html}} diantaranya yaitu:
\subsubsection{\textit{Radio Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.radio & Paket yang berisi kelas terkait dengan radio \\
\hline
2 & com.virtenio.radio.ieee\_802\_15\_4 & Paket yang berisi kelas terkait dengan IEEE 802.15.4\\
\hline
\end{tabular}
\end{center}
\subsubsection{Java \textit{Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & java.io & Paket yang berisi kelas terkait Java IO \\
\hline
2 & java.lang & Paket yang berisi kelas terkait Java \textit{lang}  \\
\hline
2 & java.lang.ref & Paket yang berisi kelas terkait Java \textit{ref}  \\
\hline
3 & java.math & Paket yang berisi kelas terkait Java \textit{mathematic} \\
\hline
4 & java.nio & Paket yang berisi kelas terkait Java \textit{nio} \\
\hline
5 & java.nio.channels & Paket yang berisi kelas terkait Java \textit{channels}  \\
\hline
6 & java.text & Paket yang berisi kelas terkait Java \textit{text} \\
\hline
7 & java.util & Paket yang berisi kelas terkait Java \textit{Utility}  \\
\hline
8 & java.util.concurrent & Paket yang berisi kelas terkait Java \textit{concurrent} \\
\hline
9 & java.util.concurrent.atomic & Paket yang berisi kelas terkait Java \textit{atomic}  \\
\hline
10 & java.util.concurrent.locks & Paket yang berisi kelas terkait Java \textit{locks} \\
\hline
11 & java.util.regex & Paket yang berisi kelas terkait Java \textit{Reguler Expression} \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Preon32 Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.preon32.cpu & Paket yang berisi kelas terkait dengan CPU di Preon32  \\
\hline
2 & com.virtenio.preon32.mainboard & Paket yang berisi kelas terkait dengan \textit{mainboard} di Preon32  \\
\hline
3 & com.virtenio.preon32.node & Paket yang berisi kelas terkait dengan \textit{node} di Preon32 \\
\hline
4 & com.virtenio.preon32.shuttle & Paket yang berisi kelas terkait dengan Preon32 Shuttle \\
\hline
\end{tabular}
\end{center} 
\subsubsection{\textit{Commander Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.commander & Paket yang berisi tentang \textit{commander}  \\
\hline
2 & com.virtenio.commander.comportserver & Paket yang berisi kelas tentang \textit{comport server commander}  \\
\hline
3 & com.virtenio.commander.io & Paket yang berisi kelas tentang \textit{input output commander}  \\
\hline
4 & com.virtenio.commander.misc & Paket yang berisi kelas terkait tentang MISC \textit{commander} \\
\hline
5 & com.virtenio.commander.res & Paket yang berisi kelas tentang \textit{result commander}  \\
\hline
6 & com.virtenio.commander.toolsets & Paket yang berisi tentang \textit{toolsets commander}  \\
\hline
7 & com.virtenio.commander.toolsets.common & Paket yang berisi kelas tentang \textit{toolsets common commander}  \\
\hline
8 & com.virtenio.commander.toolsets.preon32 & Paket yang berisi kelas tentang \textit{toolsets} Preon32 \textit{commander} \\
\hline
9 & com.virtenio.commander.ui & Paket yang berisi kelas terkait dengan UI \textit{commander}  \\
\hline
10 & com.virtenio.commander.ui.res & Paket yang berisi kelas terkait dengan \textit{result} UI \textit{commander}  \\
\hline
\end{tabular}
\end{center} 


\newpage
\subsubsection{\textit{Driver Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.driver & Paket yang berisi driver untuk berbagai macam perangkat  \\
\hline
2 & com.virtenio.driver.adc & Paket yang berisi tentang kelas ADC \textit{driver}  \\
\hline
3 & com.virtenio.driver.button & Paket yang berisi tentang kelas \textit{button} \textit{driver}  \\
\hline
4 & com.virtenio.driver.can & Paket yang berisi tentang kelas CAN \textit{driver}  \\
\hline
5 & com.virtenio.driver.cpu & Paket yang berisi tentang kelas CPU \textit{driver}  \\
\hline
6 & com.virtenio.driver.device & Paket yang berisi tentang kelas \textit{device} \textit{driver}  \\
\hline
7 & com.virtenio.driver.device.at86rf231 & Paket yang berisi tentang driver untuk perangkat AT86RF231\\
\hline
8 & com.virtenio.driver.flash & Paket yang berisi tentang kelas Flash \textit{driver}  \\
\hline
9 & com.virtenio.driver.gpio & Paket yang berisi tentang kelas GPIO \textit{device driver}  \\
\hline
10 & com.virtenio.driver.i2c & Paket yang berisi tentang kelas I2C \textit{device driver}  \\
\hline
11 & com.virtenio.driver.irq & Paket yang berisi tentang kelas IRQ \textit{device driver}  \\
\hline
12 & com.virtenio.driver.led & Paket yang berisi tentang kelas LED \textit{device driver}  \\
\hline
13 & com.virtenio.driver.lin & Paket yang berisi tentang kelas LIN \textit{device driver}  \\
\hline
14 & com.virtenio.driver.onewire & Paket yang berisi tentang kelas OneWire \textit{device driver}  \\
\hline
15 & com.virtenio.driver.pwm & Paket yang berisi tentang kelas PWM \textit{device driver}  \\
\hline
16 & com.virtenio.driver.ram & Paket yang berisi tentang kelas RAM \textit{device driver}  \\
\hline
17 & com.virtenio.driver.realtimeclock & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time clock} \textit{device driver}  \\
\hline
18 & com.virtenio.driver.realtimecounter & Paket yang berisi tentang kelas untuk pengaturan jam secara \textit{real time counter} \textit{device driver}  \\
\hline
19 & com.virtenio.driver.spi & Paket yang berisi tentang kelas SPI \textit{device driver}  \\
\hline
20 & com.virtenio.driver.switch\_ & Paket yang berisi tentang kelas \textit{switch} \textit{driver}  \\
\hline
21 & com.virtenio.driver.timer & Paket yang berisi tentang kelas \textit{hardware timer device driver}  \\
\hline
22 & com.virtenio.driver.usart & Paket yang berisi tentang kelas USART \textit{device driver}  \\
\hline
23 & com.virtenio.driver.watchdog & Paket yang berisi tentang kelas \textit{watchdog} \textit{device driver}  \\
\hline
\end{tabular}
\end{center}

\subsubsection{\textit{Other Packages}}
\begin{center}
\begin{tabular}{|c|p{7cm}|p{7cm}|} 
\hline
No & \hspace{2.5cm} Package & \hspace{2.5cm}Deskripsi \\
\hline
1 & com.virtenio.crypt & Paket Virternio VM yang berisi terkait dengan \textit{cript} \\
\hline
2 & com.virtenio.io & Paket Virternio VM yang berisi terkait dengan IO  \\
\hline
3 & com.virtenio.math & Paket Virternio VM yang berisi terkait dengan \textit{mathematic}  \\
\hline
4 & com.virtenio.misc & Paket Virternio VM yang berisi terkait dengan MISC  \\
\hline
5 & com.virtenio.net & Paket Virternio VM yang berisi terkait dengan \textit{network} \\
\hline
6 & com.virtenio.net.lowpan & Paket Virternio VM yang berisi terkait dengan \textit{lowpan}  \\
\hline
7 & com.virtenio.route.aodv & Paket Virternio VM yang berisi terkait dengan AODV \\
\hline
8 & com.virtenio.vm.event & Paket Virternio VM yang berisi terkait dengan \textit{event asynchronous} dan \textit{synchronous}   \\
\hline
9 & com.virtenio.flashlogger & Paket Virternio VM yang berisi terkait dengan Flashlogger  \\
\hline
\end{tabular}
\end{center}

\section{\textit{Universal Serial Bus}}
\textit{Universal Serial Bus} atau USB merupakan sebuah perangkat penghubung antara komputer dengan \textit{peripheral eksternal}. Kelebihan utama yang dimiliki oleh \textit{Universal Serial Bus} atau USB yaitu \textit{hot plugable}, yang berarti perangkat \textit{Universal Serial Bus} atau USB dapat di \textit{plug} ke komputer pada saat komputer sedang berjalan dan dapat mongkonfigurasnya secara otomatis.\cite{usb} Saat ini, \textit{Universal Serial Bus} atau USB sudah memiliki 3 versi standar utama, dengan dua revisi besar didalamnya. Ketiga versi ini akan dijelaskan sebagai berikut:
\begin{enumerate}
    \item USB 1.0 \newline
    USB 1.0 merupakan versi awal dari \textit{Universal Serial Bus} atau USB. USB 1.0 memiliki dua mode, yaitu \textit{low speed} dan \textit{full speed}.
    \item USB 2.0 \newline
    USB 2.0 merupakan perbaikan dari USB 1.1, terutama dari sisi kemampuan transfer data. USB 2.0 ini memiliki mode baru yang disebut sebagai \textit{high speed/hi-speed}.
    \item USB 3.0 \newline
    USB-IF mendesain standar ini agar tetap memiliki \textit{backward compatibility} dengan standar sebelumnya.Kecepatan menjadi salah satu peningkatan yang ada pada versi ini.USB 3.0 ini memperkenalkan mode baru, yaitu \textit{super speed}. USB 3.0 ini juga mengubah mode operasi USB dari semula \textit{half-duplex} di USB 1.0/USB 1.1 dan USB 2.0, menjadi \textit{full-duplex}. Terjadi perubahan penamaan untuk USB 3.0 yang digantikan menjadi dengan nama USB 3.1 Gen. 1 digunakan untuk menyebut USB 3.0, serta USB 3.1 Gen. 2 untuk Ã¢â?¬Å?USB 3.1 yang sesungguhnyaÃ¢â?¬ï¿½, dalam mode Super Speed+. USB 3.1 kembali menawarkan perbaikan dari sisi kecepatan, serta tetap mempertahankan kompatibilitas dengan standar sebelumnya.
\end{enumerate}
Berikut pada Tabel merupakan tabel \ref{Perbandingan} perbandingan data rate dan kecepatan transfer data dari standar USB yang ada:
\begin{table}[H]
\centering
\begin{tabular}{ |c|p{6cm}|p{4cm}| } 
\hline
\rowcolor{lightgray} No & \centering{Standar (Mode)} & \hspace{0.5 cm} Max. Data Rate \\ 
\hline
 1 & USB 1.0 (Low Speed) & 1.5 Mbit/s\\ 
\hline
2 & USB 1.0 (Full Speed) & 12 Mbit/s \\
\hline
3 & USB 2.0 (High Speed) & 480 Mbit/s \\
\hline
4 & USB 3.0/USB 3.1 Gen.1 (Super Speed) & 5 Gbit/s \\
\hline
5 & USB 3.1/USB 3.1 Gen.2 (Super Speed) & 10 Gbit/s\\
\hline
\end{tabular}
\caption{Perbandingan Data Rate dan Kecepatan Transfer Data}
\label{Perbandingan}
\end{table}

Data \textit{rate} yang tercantum di dalam Tabel \ref{Perbandingan} adalah data \textit{rate} maksimal yang secara teori bisa dicapai oleh satu \textit{controller}. Bila satu \textit{controller} menangani lebih dari satu \textit{port}, maka \textit{data rate} akan dibagi antar \textit{port-port} tersebut berdasarkan mekanisme tertentu. Selain itu, data \textit{rate} maksimal pada umumnya tidak bisa dicapai dalam penggunaan karena terdapat \textit{overhead} di paket yang dikirimkan dan limitasi bus.



\subsection{Jenis-jenis \textit{Universal Serial Bus}}
\textit{Universal Serial Bus} sendiri hadir dalam berbagai macam bentuk atau tipe yang umum digunakan yaitu:

\subsubsection{USB Tipe-A}
USB Tipe-A merupakan tipe USB yang paling umum digunakan. Contohnya untuk sambungan perangkat \textit{mobile}, komputer, konsol \textit{game} PlayStation, XBOX. Berikut pada Gambar \ref{fig: TipeA} merupakan bentuk dari USB Tipe-A
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeA.jpg}
    \caption{USB Tipe-A}
    \label{fig: TipeA}
\end{figure}
\newpage
\subsubsection{USB Tipe-B}
USB Tipe-B merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer. Popularitas USB Tipe-B ini semakin menurun karena sudah bermunculan tipe USB lain yang bentuknya lebih kecil dan efisien. Berikut pada Gambar \ref{fig: TipeB} merupakan bentuk dari USB Tipe-B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeB.jpg}
    \caption{USB Tipe-B}
    \label{fig: TipeB}
\end{figure}

\subsubsection{USB Tipe-C}
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24-pin \textit{reversible} sebagai konektor baru untuk \textit{interface} USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik. USB Tipe-C dapat mengalirkan daya dan memindahkan data jauh lebih cepat dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: TipeC} merupakan bentuk dari USB Tipe-C
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/TipeC.jpg}
    \caption{USB Tipe-C}
    \label{fig: TipeC}
\end{figure}
\subsubsection{USB Micro}
Jenis USB ini memiliki bentuk yang lebar dan pipih. Biasanya disematkan di ponsel pintar kelas menengah kebawah dan digunakan untuk transfer data dan pengisian daya baterai kamera digital. Berikut pada Gambar \ref{fig: Micro} merupakan bentuk dari USB Micro
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Micro.jpg}
    \caption{USB Micro}
    \label{fig: Micro}
\end{figure}
\pagebreak
\subsubsection{USB Micro B Superspeed}
Jenis USB ini umumnya digunakan untuk menyambungkan \textit{hard disk} eksternal ke komputer dan televisi dengan memiliki kemampuan transfer data yang sangat cepat hingga 5 Gbps. Jenis USB ini memiliki bentuk yang panjang dan pipih. Berikut pada Gambar \ref{fig: MicroB} merupakan bentuk dari USB Micro B
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/MicroB.jpg}
    \caption{USB Micro B }
    \label{fig: MicroB}
\end{figure}

\subsubsection{USB Mini}
Jenis USB ini umumnya digunakan untuk banyak perangkat \textit{mobile} seperti ponsel, MP3 \textit{player}, \textit{gamepad} konsol PlayStation. Jenis USB ini memiliki bentuk kecil namun lebih tebal jika dibandingkan dengan jenis USB lainnya. Berikut pada Gambar \ref{fig: Mini} merupakan bentuk dari USB Mini
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Mini.jpg}
    \caption{USB Mini}
    \label{fig: Mini}
\end{figure}

\subsubsection{USB Lighting}
Jenis USB ini digunakan khusus hanya untuk produk buatan Apple dalam hal menyambungkan perangkat \textit{mobile} mereka baik iPhone maupun iPad ke komputer, adaptor listrik, dan \textit{power bank}. Berikut pada Gambar \ref{fig: Lighting} merupakan bentuk dari USB Lighting
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{Gambar/Lightning.jpg}
    \caption{USB Lighting}
    \label{fig: Lighting}
\end{figure}
\pagebreak
\section{UART dan USART\cite{UART} \cite{UART2}}
\textit{Universal Asynchronous Receiver Transmitter} (UART) merupakan sebuah bagian dari perangkat keras komputer yang berjenis \textit{asynchronous receiver/transmitter} yang dapat menerjemahkan data antara modul paralel dan serial. \textit{Universal Asynchronous Receiver Transmitter} (UART) ini juga biasanya merupakan sebuah sirkuit terintegrasi yang digunakan untuk komunikasi serial pada komputer atau  \textit{port} serial perangkat periperal. UART biasanya digunakan di mikrokontroler dan tersedia di berbagai perangkat komunikasi seperti komunikasi nirkabel, unit GPS, modul Bluetooth, dan banyak aplikasi lainnya seperti 8250 UART. Berikut pada Gambar \ref{fig: UART} merupakan bentuk dari 8250 UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{Gambar/UART.jpg}
    \caption{UART 8250}
    \label{fig: UART}
\end{figure}
\newline
UART mencakup \textit{transmitter} dan \textit{receiver}. \textit{Transmitter} mengontrol transmisi dengan mengambil kata data dalam format paralel dan mengarahkan UART untuk mengirimkannya secara serial. Sedangkan \textit{receiver} harus mendeteksi transmisi, menerima data secara serial, dan menyimpan kata data dalam format paralel. Konversi data serial ke paralel ditangani oleh UART. Komunikasi serial mengurangi distorsi sinyal, oleh karena itu transfer data dimungkinkan antara dua sistem yang dipisahkan oleh jarak yang sangat jauh. Pada Gambar \ref{fig: diagram} ditunjukkan bentuk diagram dari UART.
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Diagram UART.jpg}
    \caption{Diagram UART}
    \label{fig: diagram}
\end{figure}
\newline
Komunikasi UART dapat dilakukan menggunakan tiga sinyal seperti TXD, RXD, dan GND. TXD adalah sisi transmisi, yaitu output dari UART sedangkan RXD adalah penerima, yaitu input UART. Modul serial UART dibagi menjadi tiga sub modul yaitu: 
\begin{enumerate}
    \item \textit{Baud rate generator}. \newline
    \textit{Baud rate generator} adalah sejenis pembagi frekuensi dan berfungsi untuk menghasilkan sinyal \textit{clock} lokal. Pada \textit{baud rate}, faktor frekuensi dapat dihitung sesuai dengan frekuensi \textit{clock} sistem yang diberikan dan kecepatan baud yang diperlukan. Kemudian \textit{baud rate}, faktor frekuensi tersebut dapat dihitung dan digunakan sebagai faktor pemisah. Biasanya besar \textit{baud rate} adalah sebesar 9600 \textit{bps}.
    \item Modul \textit{receiver}. \newline
    Modul \textit{receiver} UART digunakan untuk menerima sinyal serial di RXD dan mengubahnya menjadi data paralel.
    \item Modul \textit{transmitter}. \newline
    Modul \textit{transmitter} UART digunakan untuk mengubah \textit{byte} data menjadi \textit{bit} serial sesuai dengan format \textit{frame} dan mengirimkan \textit{bit} tersebut melalui TXD.
\end{enumerate}
\textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) merupakan sebuah komunikasi yang memiliki fleksibilitas tinggi, yang dapat digunakan untuk melakukan transfer data baik antara mikrokontroler maupun dengan modul-modul eksternal termasuk PC yang memiliki fitur \textit{Universal Asynchronous Receiver Transmitter} (UART). \textit{Universal Synchronous/Asynchronous Receiver/Transmitter} (USART) ini juga memungkinkan transmisi data baik secara \textit{syncrhronous} maupun \textit{asyncrhronous}, sehingga dengan memiliki \textit{Universal Synchronous Asynchronous Receiver Transmitter} (USART) dapat dipastikan kompatibel dengan \textit{Universal Asynchronous Receiver Transmitter} (UART).

\subsection{Fitur Dasar UART \cite{UART2}}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{Gambar/Format Frame UART.jpg}
    \caption{Format \textit{Frame} UART}
    \label{fig: format}
\end{figure}

UART memiliki fitur dasar berupa dua status dalam garis sinyal yaitu menggunakan logika tinggi dan logika rendah untuk membedakannya. UART memiliki format \textit{frame} seperti yang ditunjukkan pada Gambar \ref{fig: format} dan akan dijelaskan sebagai berikut:
\subsubsection{\textit{Start Bit}}
Saluran transmisi data UART biasanya berada pada level tegangan tinggi saat tidak mengirimkan data. Untuk memulai transfer data, \textit{transmitter} UART menarik saluran transmisi dari tinggi ke rendah untuk satu \textit{clock cycles}. Ketika \textit{receiver} UART mendeteksi transisi tegangan tinggi ke rendah, ia mulai membaca \textit{bit} dalam data \textit{frame} pada frekuensi \textit{baud rate}. 

\subsubsection{\textit{Data Bits}}
\textit{Data bits} berisi data aktual yang sedang ditransfer. Panjangnya bisa 5 \textit{bit} hingga 8 \textit{bit} jika menggunakan \textit{parity bit}. Jika tidak ada \textit{parity bit} yang digunakan, \textit{data bits} dapat berukuran 9 \textit{bit}. Dalam kebanyakan kasus, data dikirim dengan \textit{bit} yang paling tidak signifikan terlebih dahulu.

\subsubsection{\textit{Parity Bit}}
\textit{Parity} menggambarkan bilangan ganjil atau genap dari sebuah angka. \textit{Parity bit} adalah cara bagi UART penerima untuk mengetahui apakah ada data yang berubah selama transmisi. \textit{Bit} dapat diubah dengan radiasi elektromagnetik, \textit{baud rate} yang tidak sesuai, atau transfer data jarak jauh. Setelah UART penerima membaca \textit{data bits}, UART akan menghitung jumlah \textit{bit} dengan nilai 1 dan memeriksa apakah totalnya adalah bilangan genap atau ganjil. Jika \textit{parity bit} adalah 0 (\textit{parity} genap), 1 \textit{bit} dalam \textit{data bits} harus berjumlah bilangan genap. Jika \textit{parity bit} adalah 1 (\textit{parity} ganjil), 1 \textit{bit} dalam \textit{data bits} harus berjumlah ganjil. Ketika \textit{parity bit} cocok dengan data, UART akan menandakan bahwa transmisi bebas dari kesalahan. Tetapi jika \textit{parity bit} adalah 0, dan totalnya ganjil atau \textit{parity bit} adalah 1, dan totalnya genap, UART akan mengetahui bahwa \textit{bits} dalam \textit{data frame} telah berubah.

\subsubsection{\textit{Stop Bit}}
Untuk memberi sinyal akhir dari paket data, driver UART mengirimkan jalur transmisi data dari tegangan rendah ke tegangan tinggi untuk setidaknya dua durasi \textit{bit}. Data \textit{asynchronous} bersifat Ã¢â?¬Å?\textit{self synchronizing}Ã¢â?¬ï¿½ yang berarti jika tidak ada data untuk dikirim maka saluran transmisi tersebut akan menganggur.

\subsection{Perbedaan UART dan USART}
Pada Tabel \ref{Perbedaan} akan dijelaskan tentang perbedaan \textit{Universal Asynchronous Receiver Transmitter} (UART) dan\textit{Universal Syncrhronous Asynchronous Receiver Transmitter} (USART).
\begin{table}[H]
    \centering
\begin{tabular}{ |c|p{3.5cm}|p{6cm}|p{6cm}| } 
\hline
%\rowcolor{lightgray} \multicolumn{4}{|c|}{Tabel Perbedaan UART dan USART} \\
%\hline
\rowcolor{lightgray} No & \centering{Pembanding} & \hspace{2.3cm}UART & \hspace{2 cm} USART \\ 
\hline
 1 & Duplex & Menggunakan \textit{full duplex}  & Menggunakan \textit{half duplex} \\ 
\hline
2 & Kecepatan & Lebih lambat & Lebih cepat \\
\hline
3 & Kompleksitas & Lebih simple & Lebih rumit \\
\hline
4 & \textit{Function} & Hanya menggunakan sinyal data & Menggunakan sinyal data dan \textit{clock} \\
\hline
5 & Transmisi Data & Data di transmisikan dalam bentuk \textit{bytes} dengan kecepatan variabel  & Data di transmisikan dalam bentuk \textit{blocks} dengan kecepatan tertentu\\
\hline
6 & Penggunaan Fungsi & Tidak dapat menjalankan fungsi USART & Dapat menjalankan fungsi UART \\
\hline
7 & Kecepatan Pemancar & Penerima harus mengetahuinya karena tidak memiliki \textit{clock signal}  & Penerima tidak harus mengetahui karena sudah mendapatkan informasi tersebut dari \textit{master} dan \textit{clock signal}\\
\hline

\end{tabular}
\label{Perbedaan}
\caption{Perbedaan UART dan USART}
\end{table}













USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.

USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.
USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.
File ke 1
Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file dari file ke 2
Preon32
File ke 1 Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file tes

USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.

USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.
USB TipeB merupakan tipe USB yang digunakan untuk menyambungkan printer dan scanner ke komputer.
Popularitas USB TipeB ini semakin menurun karena sudah bermunculan tipe USB 
lain yang bentuknya lebih kecil dan efisien. 
Berikut pada Gambar reffig TipeB merupakan bentuk dari USB TipeB.
USB Type C ini lebih merujuk ke standar yang menetapkan konektor 24pin 
textitreversible sebagai konektor baru untuk textitinterface USB. Bentuknya oval dan simetris, sehingga dapat digunakan dalam posisi terbalik.
File ke 1
Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file dari file ke 2
Preon32
File ke 1 Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file tes
File ke 1
Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file dari file ke 2
Preon32
File ke 1 Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file tes
File ke 1
Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file dari file ke 2
Preon32
File ke 1 Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file tes
Berikut merupakan contoh isi file tes
File ke 1 Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file tes
Berikut merupakan contoh isi file tes
File ke 1 Preon32 merupakan sebuah sensor yang sedang digunakan dalam skripsi ini
Berikut merupakan contoh isi file tes
Berikut merupakan contoh isi file tes
selesai selesai selesai selesai selesai selesai selesai selesai selesai selesai selesai selesai